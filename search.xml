<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF1B(Spreadsheets)</title>
    <url>/2020/08/14/CF1B/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.</p>
<p>The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23.</p>
<p>Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.</p>
<p>Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line of the input contains integer number nn ( $ 1\le n\le 10^{5} $), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than $10^{6}$.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Write n lines, each line should contain a cell coordinates in the other numeration system.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>输入之后，要仔细分辨是哪种坐标系统，如果是R23C55这种的，它会有从数字到字母的转折点，但是对于excel的坐标系统来说，就没有这么个转折点了，这就为我们分辨它是哪种坐标系统方式提供了依据。</p>
<p>分辨之后，用26进制计算即可，注意了，这里的26进制是1<del>26而不是0</del>25，注意这一点之后，就能轻松ac。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = str[i];</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> it = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		a1 *= <span class="number">10</span>;</span><br><span class="line">		a1 += it;</span><br><span class="line">		c = str[++i];</span><br><span class="line">		<span class="keyword">if</span> ((c &gt; <span class="string">&#x27;9&#x27;</span>) || (c &lt; <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		c = str[i++];</span><br><span class="line">		a2 *= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> it = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		a2 += it;</span><br><span class="line">	&#125;</span><br><span class="line">	stack&lt;<span class="keyword">char</span>&gt; mystack;</span><br><span class="line">	<span class="keyword">while</span> (a2) &#123;</span><br><span class="line">		<span class="keyword">int</span> it = a2 % <span class="number">26</span>;</span><br><span class="line">		a2 /= <span class="number">26</span>;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="keyword">if</span> (!it) &#123;</span><br><span class="line">			c = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">			a2--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			c = <span class="string">&#x27;A&#x27;</span> + it - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mystack.<span class="built_in">push</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!mystack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; mystack.<span class="built_in">top</span>();</span><br><span class="line">		mystack.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = str[i];</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> it = c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">		a1 *= <span class="number">26</span>;</span><br><span class="line">		a1 += it;</span><br><span class="line">		c = str[++i];</span><br><span class="line">		<span class="keyword">if</span> ((c &lt; <span class="string">&#x27;A&#x27;</span>) || (c &gt; <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		c = str[i++];</span><br><span class="line">		<span class="keyword">int</span> it = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		a2 *= <span class="number">10</span>;</span><br><span class="line">		a2 += it;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&#x27;R&#x27;</span> &lt;&lt; a2 &lt;&lt; <span class="string">&#x27;C&#x27;</span> &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; str.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((str[i - <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (str[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) &amp;&amp; (str[i] &gt;= <span class="string">&#x27;A&#x27;</span>) &amp;&amp; (str[i]) &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="built_in">change1</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">change2</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1A(Theatre Square)</title>
    <url>/2020/08/14/CF1A/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Theatre Square in the capital city of Berland has a rectangular shape with the size $n\times m$ meters. On the occasion of the city’s anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size $a\times a$ .</p>
<p>What is the least number of flagstones needed to pave the Square? It’s allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It’s not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The input contains three positive integer numbers in the first line: n,m and a ( $1\leq n,m,a\leq 10^{9} $).</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Write the needed number of flagstones.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>不是很难，但也有坑，如果n或者m不是a的整数倍，但是题目中说了3个数字都是整数型的，那么无论是$ n\div a$还是$m \div a$都会在程序中自动省略小数部分，但这明显不是我们要的答案，所以我们在除之前看看$ n% a==0$?和$m% a==0$?，如果不是，对应的商要加一。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> m, n, a;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n &gt;&gt; a;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans  = m / a;</span><br><span class="line">	<span class="keyword">if</span> (m%a != <span class="number">0</span>) &#123;</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> an = n / a;</span><br><span class="line">	<span class="keyword">if</span> (n%a != <span class="number">0</span>) &#123;</span><br><span class="line">		an++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ans*an) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2B(The least round way)</title>
    <url>/2020/08/27/CF2B/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>There is a square matrix $n \times n$ , consisting of non-negative integer numbers. You should find such a way on it that</p>
<ul>
<li>starts in the upper left cell of the matrix;</li>
<li>each following cell is to the right or down from the current cell;</li>
<li>the way ends in the bottom right cell.</li>
</ul>
<p>Moreover, if we multiply together all the numbers along the way, the result should be the least “round”. In other words, it should end in the least possible number of zeros.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>he first line contains an integer number $ n (2\le n\le 1000) $, $n$ is the size of the matrix. Then follow $n$ lines containing the matrix elements (non-negative integer numbers not exceeding $10^{9}$).</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>做一题第一次了解到,cin函数是有多慢，模仿大佬写了一个read函数，一直报TLE的测试点直接过，不过想想确实，极端情况下数据都是$1000\times 1000$的cin，如果都是cin的话，确实速度会慢很多，同时注意到这是一个从左上向右下的处理过程，那么我们可以用滚动数组去节省空间。</p>
<p>他是先从左上角开始处理，一直遍历到右下角。如果数的尾端要再出现0，那么它乘的数有两种可能：</p>
<ul>
<li>乘数是2和5的倍数</li>
<li>乘数是0</li>
</ul>
<p>对于第一种情况，我们用一个arr数组记录下从左上角遍历到(i,j)位置中所遇到的最少的2和5，同时用way数组记录下行走路线。</p>
<p>对于第二种情况，任何数乘上0后都为0，那么数字末尾0的个数必定为1，记录下来。</p>
<p>输出结果时，要产生1个0，就要有一对2和5，所以答案可能是min(arr[n-1][0],arr[n-1][1])，但是如果数组中有0的存在，也就是出现了第二种情况，且min(arr[n-1][0],arr[n-1][1])&gt;1，那么就输出经过0的路径就好了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> arr[<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line">string way[<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> best;</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">long</span> t;</span><br><span class="line">	t = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span> (!t) &#123;</span><br><span class="line">		arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		best = <span class="number">0</span>;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">			arr[<span class="number">0</span>][<span class="number">0</span>]++;</span><br><span class="line">			t /= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">5</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">			arr[<span class="number">0</span>][<span class="number">1</span>]++;</span><br><span class="line">			t /= <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">		t = <span class="built_in">read</span>();</span><br><span class="line">		way[i][<span class="number">0</span>] = way[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="string">&quot;R&quot;</span>;</span><br><span class="line">		way[i][<span class="number">1</span>] = way[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (!t) &#123;</span><br><span class="line">			arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			arr[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			best = i;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			arr[i][<span class="number">0</span>] = arr[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">			arr[i][<span class="number">1</span>] = arr[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">				arr[i][<span class="number">0</span>]++;</span><br><span class="line">				t /= <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">5</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">				arr[i][<span class="number">1</span>]++;</span><br><span class="line">				t /= <span class="number">5</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">		way[<span class="number">0</span>][<span class="number">0</span>] = way[<span class="number">0</span>][<span class="number">0</span>] + <span class="string">&quot;D&quot;</span>;</span><br><span class="line">		way[<span class="number">0</span>][<span class="number">1</span>] = way[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		t = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span> (!t) &#123;</span><br><span class="line">			arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			best = <span class="number">0</span>;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">				arr[<span class="number">0</span>][<span class="number">0</span>]++;</span><br><span class="line">				t /= <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">5</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">				arr[<span class="number">0</span>][<span class="number">1</span>]++;</span><br><span class="line">				t /= <span class="number">5</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">			t = <span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span> (!t) &#123;</span><br><span class="line">				arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">				arr[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">				way[i][<span class="number">0</span>] = way[i][<span class="number">0</span>] + <span class="string">&quot;D&quot;</span>;</span><br><span class="line">				way[i][<span class="number">1</span>] = way[i][<span class="number">0</span>];</span><br><span class="line">				best = i;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i - <span class="number">1</span>][<span class="number">0</span>] &lt; arr[i][<span class="number">0</span>]) &#123;</span><br><span class="line">					arr[i][<span class="number">0</span>] = arr[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">					way[i][<span class="number">0</span>] = way[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="string">&quot;R&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					way[i][<span class="number">0</span>] = way[i][<span class="number">0</span>] + <span class="string">&quot;D&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (arr[i - <span class="number">1</span>][<span class="number">1</span>] &lt; arr[i][<span class="number">1</span>]) &#123;</span><br><span class="line">					arr[i][<span class="number">1</span>] = arr[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">					way[i][<span class="number">1</span>] = way[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="string">&quot;R&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					way[i][<span class="number">1</span>] = way[i][<span class="number">1</span>] + <span class="string">&quot;D&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">					arr[i][<span class="number">0</span>]++;</span><br><span class="line">					t /= <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (t &amp;&amp; (t % <span class="number">5</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">					arr[i][<span class="number">1</span>]++;</span><br><span class="line">					t /= <span class="number">5</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((flag == <span class="number">1</span>) &amp;&amp; (flag &lt; arr[n - <span class="number">1</span>][<span class="number">0</span>]) &amp;&amp; (flag &lt; arr[n - <span class="number">1</span>][<span class="number">1</span>])) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">		best++;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>;i &lt; best;i++) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;R&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;D&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = best;i &lt; n;i++) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;R&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[n - <span class="number">1</span>][<span class="number">0</span>] &lt; arr[n - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">			cout &lt;&lt; arr[n - <span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; way[n - <span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; arr[n - <span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; way[n - <span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2C(Commentator problem)</title>
    <url>/2020/08/30/CF2C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>The Olympic Games in Bercouver are in full swing now. Here everyone has their own objectives: sportsmen compete for medals, and sport commentators compete for more convenient positions to give a running commentary. Today the main sport events take place at three round stadiums, and the commentator’s objective is to choose the best point of observation, that is to say the point from where all the three stadiums can be observed. As all the sport competitions are of the same importance, the stadiums should be observed at the same angle. If the number of points meeting the conditions is more than one, the point with the maximum angle of observation is prefered.</p>
<p>Would you, please, help the famous Berland commentator G. Berniev to find the best point of observation. It should be noted, that the stadiums do not hide each other, the commentator can easily see one stadium through the other.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The input data consists of three lines, each of them describes the position of one stadium. The lines have the format $x,y,r$ , where $(x,y)$ are the coordinates of the stadium’s center $(-10^{3}\le x,y\le 10^{3})$, and $r (1\le r\le 10^{3})$ is its radius. All the numbers in the input data are integer, stadiums do not have common points, and their centers are not on the same line.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print the coordinates of the required point with five digits after the decimal point. If there is no answer meeting the conditions, the program shouldn’t print anything. The output data should be left blank.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>真就现在水平还不如高三呗，未知数多点就傻了。</p>
<p>设我们要求的点为$(x,y)$，观察角的一半为$\theta $。</p>
<p>$\therefore$<br>$$ (x-x_1)^2+(y-y_1)^2=\frac{r_1^2}{sin(\theta )^2}$$<br>$$ (x-x_2)^2+(y-y_2)^2=\frac{r_2^2}{sin(\theta )^2}$$<br>$$ (x-x_3)^2+(y-y_3)^2=\frac{r_3^2}{sin(\theta )^2}$$</p>
<p>然后由三个式子两两相除可以得到：<br>$$r_2^2\times (x-x_1)^2+r_2^2\times (y-y_1)^2=r_1^2\times (x-x_2)^2+r_1^2\times (y-y_2)^2$$<br>$$r_2^2\times (x-x_3)^2+r_2^2\times (y-y_3)^2=r_3^2\times (x-x_2)^2+r_3^2\times (y-y_2)^2$$</p>
<p>由于除号的传递性，我们这需要选用两个即可，稍加整理，就能得到：<br>$(r_2^2-r_1^2)\times x^2-(2\times x_1\times r_2^2-2\times x_2\times r_1^2)x+(x_1^2r_2^2-x_2^2r_1^2)$<br>$+(r_2^2-r_1^2)\times y^2-(2\times y_1\times r_2^2-2\times y_2\times r_1^2)y+(y_1^2r_2^2-y_2^2r_1^2)=0$</p>
<p>$(r_2^2-r_3^2)\times x^2-(2\times x_3\times r_2^2-2\times x_2\times r_3^2)x+(x_3^2r_2^2-x_2^2r_3^2)$<br>$+(r_2^2-r_3^2)\times y^2-(2\times y_3\times r_2^2-2\times y_2\times r_3^2)y+(y_3^2r_2^2-y_2^2r_3^2)=0$</p>
<p>有点像圆的方程了，但是$r_1=r_2$或者$r_2=r_3$，圆就会退化成直线，我们要求的就是两个方程的交点，如果有多个交点，我们可以考虑下什么情况下观察角最大：对于任一体育场i，有$sin(\theta )=\frac{r_i}{dis_{i}},dis_i$为观察点到体育场i中心的距离，那么很显然，离得越近，角越大。</p>
<p>可能出现的几种情况：</p>
<ul>
<li>圆与圆有两个交点<br><img src="https://i.loli.net/2020/08/31/8GNO7lkm6EnBesu.png" alt="CF2C-1.png"></li>
<li>圆与圆只有一个交点<br><img src="https://i.loli.net/2020/08/31/b6ShjQaWzuUxdtV.png" alt="CF2C-2.png"></li>
<li>圆与圆相离没有交点<br><img src="https://i.loli.net/2020/08/31/qFmBio6cReNsY4W.png" alt="CF2C-3.png"></li>
<li>圆与圆包含没有交点<br><img src="https://i.loli.net/2020/08/31/XV6ubFc3qzshpaY.png" alt="CF2C-4.png"></li>
<li>圆与直线有两个交点<br><img src="https://i.loli.net/2020/08/31/89igkOub3UyDwt5.png" alt="CF2C-5.png"></li>
<li>圆与直线只有一个交点<br><img src="https://i.loli.net/2020/08/31/Squ5W623EPeK9Uj.png" alt="CF2C-6.png"></li>
<li>圆与直线没有交点<br><img src="https://i.loli.net/2020/08/31/efBz67W8rioZ9L4.png" alt="CF2C-7.png"></li>
</ul>
<p>根据不同情况分别解方程即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> x1, y11, r1, x2, y2, r2, x3, y3, r3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; x1 &gt;&gt; y11 &gt;&gt; r1;</span><br><span class="line">	cin &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; r2;</span><br><span class="line">	cin &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; r3;</span><br><span class="line">	<span class="keyword">if</span> ((r1 != r2) &amp;&amp; (r2 != r3) &amp;&amp; (r1 != r3)) &#123;</span><br><span class="line">		<span class="keyword">double</span> x12, y12, x23, y23, r12, r23;</span><br><span class="line">		x12 = (x1*r2*r2 - x2 * r1*r1) / (r2*r2 - r1 * r1);</span><br><span class="line">		y12 = (y11*r2*r2 - y2 * r1*r1) / (r2*r2 - r1 * r1);</span><br><span class="line">		x23 = (x3*r2*r2 - x2 * r3*r3) / (r2*r2 - r3 * r3);</span><br><span class="line">		y23 = (y3*r2*r2 - y2 * r3*r3) / (r2*r2 - r3 * r3);</span><br><span class="line">		r12 = <span class="built_in">sqrt</span>(x12*x12 + y12 * y12 - (x1*x1*r2*r2 - x2 * x2*r1*r1) / (r2*r2 - r1 * r1) - (y11*y11*r2*r2 - y2 * y2*r1*r1) / (r2*r2 - r1 * r1));</span><br><span class="line">		r23 = <span class="built_in">sqrt</span>(x23*x23 + y23 * y23 - (x3*x3*r2*r2 - x2 * x2*r3*r3) / (r2*r2 - r3 * r3) - (y3*y3*r2*r2 - y2 * y2*r3*r3) / (r2*r2 - r3 * r3));</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sqrt</span>((x12 - x23)*(x12 - x23) + (y12 - y23)*(y12 - y23)) == (r12 + r23)) &#123;</span><br><span class="line">			<span class="keyword">double</span> x = (x12*r23 + x23 * r12) / (r12 + r23);</span><br><span class="line">			<span class="keyword">double</span> y = (y12*r23 + y23 * r12) / (r12 + r23);</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">				x = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">				y = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">sqrt</span>((x12 - x23)*(x12 - x23) + (y12 - y23)*(y12 - y23)) &lt; (r12 + r23)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">sqrt</span>((x12 - x23)*(x12 - x23) + (y12 - y23)*(y12 - y23)) &gt; <span class="built_in">abs</span>(r12 - r23)) &#123;</span><br><span class="line">					<span class="keyword">double</span> a1 = <span class="number">2</span> * (x12 - x23);</span><br><span class="line">					<span class="keyword">double</span> b1 = <span class="number">2</span> * (y12 - y23);</span><br><span class="line">					<span class="keyword">double</span> c1 = x23 * x23 + y23 * y23 - r23 * r23 - x12 * x12 - y12 * y12 + r12 * r12;</span><br><span class="line">					<span class="keyword">double</span> a2 = y12 - y23;</span><br><span class="line">					<span class="keyword">double</span> b2 = x23 - x12;</span><br><span class="line">					<span class="keyword">double</span> c2 = x12 * y23 - x23 * y12;</span><br><span class="line">					<span class="keyword">double</span> len = <span class="built_in">sqrt</span>(r12*r12 - ((a1*x12 + b1 * y12 + c1)*(a1*x12 + b1 * y12 + c1) / (a1*a1 + b1 * b1)));</span><br><span class="line">					<span class="keyword">double</span> xx = (b2*c1 - b1 * c2) / (a2*b1 - a1 * b2);</span><br><span class="line">					<span class="keyword">double</span> yy = (a1*c2 - a2 * c1) / (a2*b1 - a1 * b2);</span><br><span class="line">					<span class="keyword">double</span> x01 = xx + len * b1 / <span class="built_in">sqrt</span>(a1*a1 + b1 * b1);</span><br><span class="line">					<span class="keyword">double</span> y01 = yy - len * a1 / <span class="built_in">sqrt</span>(a1*a1 + b1 * b1);</span><br><span class="line">					<span class="keyword">double</span> x02 = xx - len * b1 / <span class="built_in">sqrt</span>(a1*a1 + b1 * b1);</span><br><span class="line">					<span class="keyword">double</span> y02 = yy + len * a1 / <span class="built_in">sqrt</span>(a1*a1 + b1 * b1);</span><br><span class="line">					<span class="keyword">double</span> len1 = (x01 - x1)*(x01 - x1) + (y01 - y11)*(y01 - y11);</span><br><span class="line">					<span class="keyword">double</span> len2 = (x02 - x1)*(x02 - x1) + (y02 - y11)*(y02 - y11);</span><br><span class="line">					<span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">						<span class="keyword">if</span> (x01 == <span class="number">0</span>) &#123;</span><br><span class="line">							x01 = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (y01 == <span class="number">0</span>) &#123;</span><br><span class="line">							y01 = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x01 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; y01 &lt;&lt; endl;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (x02 == <span class="number">0</span>) &#123;</span><br><span class="line">							x02 = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (y02 == <span class="number">0</span>) &#123;</span><br><span class="line">							y02 = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x02 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; y02 &lt;&lt; endl;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (r2 == r3) &#123;</span><br><span class="line">			<span class="keyword">double</span> t = x1;</span><br><span class="line">			x1 = x3;</span><br><span class="line">			x3 = t;</span><br><span class="line">			t = y11;</span><br><span class="line">			y11 = y3;</span><br><span class="line">			y3 = t;</span><br><span class="line">			t = r1;</span><br><span class="line">			r1 = r3;</span><br><span class="line">			r3 = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (r1 == r3) &#123;</span><br><span class="line">				<span class="keyword">double</span> t = x2;</span><br><span class="line">				x2 = x3;</span><br><span class="line">				x3 = t;</span><br><span class="line">				t = y2;</span><br><span class="line">				y2 = y3;</span><br><span class="line">				y3 = t;</span><br><span class="line">				t = r2;</span><br><span class="line">				r2 = r3;</span><br><span class="line">				r3 = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((r1 == r2) &amp;&amp; (r2 == r3)) &#123;</span><br><span class="line">			<span class="keyword">double</span> a1 = <span class="number">2</span> * (x2 - x1);</span><br><span class="line">			<span class="keyword">double</span> b1 = <span class="number">2</span> * (y2 - y11);</span><br><span class="line">			<span class="keyword">double</span> c1 = x1 * x1 - x2 * x2 + y11 * y11 - y2 * y2;</span><br><span class="line">			<span class="keyword">double</span> a2 = <span class="number">2</span> * (x2 - x3);</span><br><span class="line">			<span class="keyword">double</span> b2 = <span class="number">2</span> * (y2 - y3);</span><br><span class="line">			<span class="keyword">double</span> c2 = x3 * x3 - x2 * x2 + y3 * y3 - y2 * y2;</span><br><span class="line">			<span class="keyword">if</span> ((a1*b2) != (a2 * b1)) &#123;</span><br><span class="line">				<span class="keyword">double</span> x = (b2*c1 - b1 * c2) / (a2*b1 - a1 * b2);</span><br><span class="line">				<span class="keyword">double</span> y = (a1*c2 - a2 * c1) / (a2*b1 - a1 * b2);</span><br><span class="line">				<span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">					x = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">					y = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">double</span> a = <span class="number">2</span> * (x2 - x1);</span><br><span class="line">			<span class="keyword">double</span> b = <span class="number">2</span> * (y2 - y11);</span><br><span class="line">			<span class="keyword">double</span> c = x1 * x1 - x2 * x2 + y11 * y11 - y2 * y2;</span><br><span class="line">			<span class="keyword">double</span> x0 = (x3*r2*r2 - x2 * r3*r3) / (r2*r2 - r3 * r3);</span><br><span class="line">			<span class="keyword">double</span> y0 = (y3*r2*r2 - y2 * r3*r3) / (r2*r2 - r3 * r3);</span><br><span class="line">			<span class="keyword">double</span> r = <span class="built_in">sqrt</span>(x0*x0 + y0 * y0 - (x3*x3*r2*r2 - x2 * x2*r3*r3) / (r2*r2 - r3 * r3) - (y3*y3*r2*r2 - y2 * y2*r3*r3) / (r2*r2 - r3 * r3));</span><br><span class="line">			<span class="keyword">double</span> len = <span class="built_in">abs</span>(a*x0 + b * y0 + c) / <span class="built_in">sqrt</span>(a*a + b * b);</span><br><span class="line">			<span class="keyword">if</span> (len == r) &#123;</span><br><span class="line">				<span class="keyword">double</span> x = (b*b*x0 - a * b*y0 - a * c) / (a*a + b * b);</span><br><span class="line">				<span class="keyword">double</span> y = (a*a*y0 - a * b*x0 - b * c) / (a*a + b * b);</span><br><span class="line">				<span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">					x = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">					y = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (len &lt; r) &#123;</span><br><span class="line">					<span class="keyword">double</span> xx = (b*b*x0 - a * b*y0 - a * c) / (a*a + b * b);</span><br><span class="line">					<span class="keyword">double</span> yy = (a*a*y0 - a * b*x0 - b * c) / (a*a + b * b);</span><br><span class="line">					<span class="keyword">double</span> xa = xx + b * <span class="built_in">sqrt</span>(r*r - len * len) / <span class="built_in">sqrt</span>(a*a + b * b);</span><br><span class="line">					<span class="keyword">double</span> ya = yy - a * <span class="built_in">sqrt</span>(r*r - len * len) / <span class="built_in">sqrt</span>(a*a + b * b);</span><br><span class="line">					<span class="keyword">double</span> xb = xx - b * <span class="built_in">sqrt</span>(r*r - len * len) / <span class="built_in">sqrt</span>(a*a + b * b);</span><br><span class="line">					<span class="keyword">double</span> yb = yy + a * <span class="built_in">sqrt</span>(r*r - len * len) / <span class="built_in">sqrt</span>(a*a + b * b);</span><br><span class="line">					<span class="keyword">double</span> len1 = (xa - x3)*(xa - x3) + (ya - y3)*(ya - y3);</span><br><span class="line">					<span class="keyword">double</span> len2 = (xb - x3)*(xb - x3) + (yb - y3)*(yb - y3);</span><br><span class="line">					<span class="keyword">if</span> (len1 &lt;= len2) &#123;</span><br><span class="line">						<span class="keyword">if</span> (xa == <span class="number">0</span>) &#123;</span><br><span class="line">							xa = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (ya == <span class="number">0</span>) &#123;</span><br><span class="line">							ya = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; xa &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; ya &lt;&lt; endl;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (xb == <span class="number">0</span>) &#123;</span><br><span class="line">							xb = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (yb == <span class="number">0</span>) &#123;</span><br><span class="line">							yb = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; xb &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; yb &lt;&lt; endl;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2A(Winner)</title>
    <url>/2020/08/20/CF2A/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>The winner of the card game popular in Berland “Berlogging” is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line “name score”, where name is a player’s name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to m ) at the end of the game, than wins the one of them who scored at least m points first. Initially each player has 0 points. It’s guaranteed that at the end of the game at least one player has a positive number of points.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains an integer number $n ( 1\le n\le 1000 ), n$ is the number of rounds played. Then follow $n$ lines, containing the information about the rounds in “name score” format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print the name of the winner.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>先用一个map统计游戏结束时所有人的得分，找到最大值，然后重新开始统计，边统计边要判断，如果当前玩家最后得到的分数是最大值，且在统计的过程中已经达到了最大值，那么他就是赢家。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mymap, mymap2;</span><br><span class="line">string name[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> sc[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">string ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; name[i] &gt;&gt; sc[i];</span><br><span class="line">		mymap[name[i]] += sc[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		m = <span class="built_in">max</span>(m, mymap[name[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		mymap2[name[i]] += sc[i];</span><br><span class="line">		<span class="keyword">if</span> ((mymap[name[i]] == m) &amp;&amp; (mymap2[name[i]] &gt;= m)) &#123;</span><br><span class="line">			ans = name[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1C(Ancient Berland Circus)</title>
    <url>/2020/08/19/CF1C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Nowadays all circuses in Berland have a round arena with diameter 13 meters, but in the past things were different.</p>
<p>In Ancient Berland arenas in circuses were shaped as a regular (equiangular) polygon, the size and the number of angles could vary from one circus to another. In each corner of the arena there was a special pillar, and the rope strung between the pillars marked the arena edges.</p>
<p>Recently the scientists from Berland have discovered the remains of the ancient circus arena. They found only three pillars, the others were destroyed by the time.</p>
<p>You are given the coordinates of these three pillars. Find out what is the smallest area that the arena could have.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The input file consists of three lines, each of them contains a pair of numbers –– coordinates of the pillar. Any coordinate doesn’t exceed 1000 by absolute value, and is given with at most six digits after decimal point.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Output the smallest possible area of the ancient arena. This number should be accurate to at least 6 digits after the decimal point. It’s guaranteed that the number of angles in the optimal polygon is not larger than 100.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>（努力回复高中做数学题的那些知识量）<br>明确目的，求一个已知三角形的外接正多边形（暂时这么命名）</p>
<p>假设输入的三个点为A,B,C，并且这三个点必定不共线。那么这三个点就必定能构成一个三角形$\triangle ABC$</p>
<p>首先，重要的一点是求出三角形的三条边a,b,c的长度，这一点没什么问题</p>
<p>求$\triangle ABC$的面积$S_{\triangle ABC}$可以海伦公式:</p>
<p>$S_{\triangle ABC}=\sqrt{p\times (p-a) \times (p-b)\times (p-c)},p=\frac{a+b+c}{2}$</p>
<p>然后求$S_{\triangle ABC}$的方式还有$S_{\triangle ABC}=\frac{a\times b\times sinC}{2}$,同时还有三角形的正弦定理$\frac{sinA}{a}=\frac{sinB}{b}=\frac{sinC}{c}=2R$,$R$是$\triangle ABC$外接圆的半径，可以推导出$R=\frac{a\times b\times c}{4S_{\triangle ABC}}$,再和海伦公式结合起来可以得出$R=\frac{a\times b\times c}{\sqrt{(a+b+c)\times (a+b-c)\times (a+c-b)\times (b+c-a)}}$</p>
<p>求出外接圆的半径远远还不够，还需要求出三角形三条边各自两个端点与外接圆对应的圆心角$A_0,B_0,C_0$。</p>
<p>根据余弦定理，显然有：</p>
<p>$a^2=2\times r^2-2\times r^2\times cosA_0$</p>
<p>$b^2=2\times r^2-2\times r^2\times cosB_0$</p>
<p>$c^2=2\times r^2-2\times r^2\times cosC_0$</p>
<p>但是，还有方法求出$A_0,B_0,C_0$:</p>
<p>$cosA_0+\frac{a^2}{2\times r^2}=1$</p>
<p>$cosB_0+\frac{b^2}{2\times r^2}=1$</p>
<p>$cosC_0+\frac{c^2}{2\times r^2}=1$</p>
<p>所以有：</p>
<p>$A_0=arccos(1-\frac{a^2}{2\times r^2})$</p>
<p>$B_0=arccos(1-\frac{b^2}{2\times r^2})$</p>
<p>$C_0=2\times \pi-A_0-B_0$</p>
<p>为什么$C_0$和$A_0,B_0$的求法不一样呢，是因为计算机计算的时候难免有误差，最后一步就是要减小这种误差。</p>
<p>算出来$A_0,B_0,C_0$之后，我们要求$A_0,B_0,C_0$的最大公约数，为什么是最大公约数呢，因为大了的话，有的圆弧上就没有整数个桩点了，如果太小了的话，想想中国古代的割圆术，那么求出来的面积不会是最小的，所以必须求公约数。</p>
<p>假设求出的公约数为t，那么马戏团可以被分成$\frac{2\times \pi}{t}$份，每一份的面积为$\frac{R^2\times sint}{2}$，那么该正多边形的面积为$\frac{\pi \times R^2 \times sint}{t}$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">double</span> A_x, A_y, B_x, B_y, C_x, C_y;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">yf</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b &lt; <span class="number">0.001</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">yf</span>(b, <span class="built_in">fmod</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; A_x &gt;&gt; A_y &gt;&gt; B_x &gt;&gt; B_y &gt;&gt; C_x &gt;&gt; C_y;</span><br><span class="line">	<span class="keyword">double</span> a = <span class="built_in">sqrt</span>((B_x - C_x)*(B_x - C_x) + (B_y - C_y)*(B_y - C_y));</span><br><span class="line">	<span class="keyword">double</span> b = <span class="built_in">sqrt</span>((A_x - C_x)*(A_x - C_x) + (A_y - C_y)*(A_y - C_y));</span><br><span class="line">	<span class="keyword">double</span> c = <span class="built_in">sqrt</span>((A_x - B_x)*(A_x - B_x) + (A_y - B_y)*(A_y - B_y));</span><br><span class="line">	<span class="keyword">double</span> r = (a*b*c) / <span class="built_in">sqrt</span>((a + b + c)*(a + b - c)*(a + c - b)*(b + c - a));</span><br><span class="line">	<span class="keyword">double</span> A = <span class="built_in">acos</span>(<span class="number">1</span> - (a * a) / (<span class="number">2</span> * r*r));</span><br><span class="line">	<span class="keyword">double</span> B = <span class="built_in">acos</span>(<span class="number">1</span> - (b * b) / (<span class="number">2</span> * r*r));</span><br><span class="line">	<span class="keyword">double</span> C = <span class="number">2</span> * pi - A - B;</span><br><span class="line">	<span class="keyword">double</span> t = <span class="built_in">yf</span>(<span class="built_in">yf</span>(A, B), C);</span><br><span class="line">	<span class="keyword">double</span> S = (pi*r*r*<span class="built_in">sin</span>(t)) / t;</span><br><span class="line">	cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF3A(Shortest path of the king)</title>
    <url>/2020/08/31/CF3A/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>The king is left alone on the chessboard. In spite of this loneliness, he doesn’t lose heart, because he has business of national importance. For example, he has to pay an official visit to square $t$ . As the king is not in habit of wasting his time, he wants to get from his current position $s$ to square $t$ in the least number of moves. Help him to do this.<br><img src="https://i.loli.net/2020/08/31/PHlOZiEyFgkqn54.png" alt="CF2C-1.png"><br>In one move the king can get to the square that has a common side or a common vertex with the square the king is currently in (generally there are 8 different squares he can move to).</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains the chessboard coordinates of square $s$ , the second line — of square $t$ .</p>
<p>Chessboard coordinates consist of two characters, the first one is a lowercase Latin letter (from a to h), the second one is a digit from 1 to 8.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>In the first line print nn — minimum number of the king’s moves. Then in nn lines print the moves themselves. Each move is described with one of the 8: L, R, U, D, LU, LD, RU or RD.</p>
<p>L, R, U, D stand respectively for moves left, right, up and down (according to the picture), and 2-letter combinations stand for diagonal moves. If the answer is not unique, print any of them.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>先看从$s$到$t$要怎么移动，向左或向右移动多少次，向上或向下移动多少次？两个次数之间可以一起移动最小的数得那部分，剩下的再单独移动。移动次数就是两个数的最大值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string t, s;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">int</span> clum = t[<span class="number">0</span>] - s[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> row = t[<span class="number">1</span>] - s[<span class="number">1</span>];</span><br><span class="line">	string c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	string r = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (clum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		c = <span class="string">&quot;R&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		c = <span class="string">&quot;L&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (row &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		r = <span class="string">&quot;U&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		r = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	clum = <span class="built_in">abs</span>(clum);</span><br><span class="line">	row = <span class="built_in">abs</span>(row);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(clum, row) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((i &lt; clum) || (i &lt; row)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; clum) &#123;</span><br><span class="line">			cout &lt;&lt; c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; row) &#123;</span><br><span class="line">			cout &lt;&lt; r ;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF3B(Lorry)</title>
    <url>/2020/09/01/CF3B/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>A group of tourists is going to kayak and catamaran tour. A rented lorry has arrived to the boat depot to take kayaks and catamarans to the point of departure. It’s known that all kayaks are of the same size (and each of them occupies the space of 1 cubic metre), and all catamarans are of the same size, but two times bigger than kayaks (and occupy the space of 2 cubic metres).</p>
<p>Each waterborne vehicle has a particular carrying capacity, and it should be noted that waterborne vehicles that look the same can have different carrying capacities. Knowing the truck body volume and the list of waterborne vehicles in the boat depot (for each one its type and carrying capacity are known), find out such set of vehicles that can be taken in the lorry, and that has the maximum total carrying capacity. The truck body volume of the lorry can be used effectively, that is to say you can always put into the lorry a waterborne vehicle that occupies the space not exceeding the free space left in the truck body.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains a pair of integer numbers $n$ and $v$ $(1\le n\le 10^{5}; 1\le v\le 10^{9})$, where $n$ is the number of waterborne vehicles in the boat depot, and $v$ is the truck body volume of the lorry in cubic metres. The following $n$ lines contain the information about the waterborne vehicles, that is a pair of numbers $t_{i}, p_{i}(1\le t_{i}\le 2; 1\le p_{i}\le 10^{4})$, where $t_{i}$is the vehicle type ( 1 – a kayak, 2 – a catamaran), and $p_{i}$is its carrying capacity. The waterborne vehicles are enumerated in order of their appearance in the input file.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>In the first line print the maximum possible carrying capacity of the set. In the second line print a string consisting of the numbers of the vehicles that make the optimal set. If the answer is not unique, print any of them.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>在重量相同的情况下，优先选择价值大的那一个，所以要将物品按价值排序，但是如果重量为1和重量为2的物品合并在一起排序，后面选择的时候就会很麻烦，所以把重量为1的分一堆排序，重量为2的分一堆排序，并且要记录下它们输入的顺序。有两种思路，其中第一种较简单，第二种稍复杂。</p>
<p>第一种：设重量为1的物品个数为$num_1$，重量为2的物品个数为$num_2$,从重量为2的数组中选取$min(v/2,num_2)$个价值最大的物品，再从重量为1的数组中选取$min(v-2\times min(v/2,num_2),num_1)$个价值最大的物品，记录下总价值；然后，从重量为2的数组中选取$min(v/2,num_2)-1$个价值最大的物品,再从重量为1的数组中选取$min(v+2-2\times min(v/2,num_2),num_1)$个价值最大的物品，记录下总价值；$\cdots$，选择其中价值最大的即是答案。</p>
<p>第二种：先从重量为1的物品中选取价值最大的那一个，计为A，再从重量为2的物品中选取价值最大的那一个，计为B，如果A的价值大于等于B，那么肯定要选择A，因为A比B轻还价值更高。如果B比A价值大，再看重量为1的物品中价值略低于A的物品，计为C。如果不存在C，那么果断选择B！如果存在C，那么就看A和C的价值之和是否大于B的价值，如果大于，就选择A和C，如果小于或等于，就选择B,注意，这里的小于等于是选择B，为什么有等于这种情况呢？假设一个货车的装载量是3，有重量为1，1，2的物品，价值分别为2，3，5。2+3=5，如果选择2和3的话，装载量只能达到2，总价值是5，可是还可以选择3和5的物品，装载量是3，总价值是8。如此反复，直到不能再放为止。但是这样仍然存在一个问题，比如一个装载量为3的火车，如果有重量为1，1，1，2，价值为5，4，3，8的物品，按照上面方法处理，装载结果为5，4，3，可是我们可以选择让价值为8的物品去替换掉价值为4和3的物品。所以，在上述步骤之后，需要从已经装载的重量为1的物品中价值最小的两个物品价值之和与未被装载的重量为1的价值最大的物品价值比较，如果小于，就替换掉。直到不能替换为止。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, v;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum1[<span class="number">100005</span>], sum2[<span class="number">100005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arr</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id, key;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(arr x, arr y) &#123;</span><br><span class="line">		<span class="keyword">return</span> x.key &gt; y.key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;arr1[<span class="number">100005</span>], arr2[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	v = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">int</span> p = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">			arr1[++num1].id = i;</span><br><span class="line">			arr1[num1].key = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			arr2[++num2].id = i;</span><br><span class="line">			arr2[num2].key = p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr1 + <span class="number">1</span>, arr1 + <span class="number">1</span> + num1);</span><br><span class="line">	<span class="built_in">sort</span>(arr2 + <span class="number">1</span>, arr2 + <span class="number">1</span> + num2);</span><br><span class="line">	<span class="keyword">int</span> len1 = <span class="built_in">min</span>(num1, v);</span><br><span class="line">	<span class="keyword">int</span> len2 = <span class="built_in">min</span>(num2, v / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++) &#123;</span><br><span class="line">		sum1[i] = sum1[i - <span class="number">1</span>] + arr1[i].key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2;i++) &#123;</span><br><span class="line">		sum2[i] = sum2[i - <span class="number">1</span>] + arr2[i].key;</span><br><span class="line">	&#125;</span><br><span class="line">	flag1 = <span class="number">0</span>;</span><br><span class="line">	flag2 = v / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = len2;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = sum1[<span class="built_in">min</span>(v - <span class="number">2</span> * j, num1)] + sum2[j];</span><br><span class="line">		<span class="keyword">if</span> (a &gt; ans) &#123;</span><br><span class="line">			ans = a;</span><br><span class="line">			flag1 = <span class="built_in">min</span>(v - <span class="number">2</span> * j, num1);</span><br><span class="line">			flag2 = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= flag1;i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr1[i].id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= flag2;i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr2[i].id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, v;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arr</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id, key;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(arr x, arr y) &#123;</span><br><span class="line">		<span class="keyword">return</span> x.key &gt; y.key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">arr</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;arr1[<span class="number">100005</span>], arr2[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">int</span> p = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">			arr1[++num1].id = i;</span><br><span class="line">			arr1[num1].key = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			arr2[++num2].id = i;</span><br><span class="line">			arr2[num2].key = p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr1 + <span class="number">1</span>, arr1 + <span class="number">1</span> + num1);</span><br><span class="line">	<span class="built_in">sort</span>(arr2 + <span class="number">1</span>, arr2 + <span class="number">1</span> + num2);</span><br><span class="line">	<span class="keyword">while</span> (v &amp;&amp; (flag1 &lt; num1) &amp;&amp; (flag2 &lt; num2)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == <span class="number">1</span>) &#123;</span><br><span class="line">			ans += arr1[++flag1].key;</span><br><span class="line">			v--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr1[flag1 + <span class="number">1</span>].key&gt;= arr2[flag2 + <span class="number">1</span>].key) &#123;</span><br><span class="line">				v--;</span><br><span class="line">				ans += arr1[++flag1].key;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> ((num1 - flag1) == <span class="number">1</span>) &#123;</span><br><span class="line">					ans += arr2[++flag2].key;</span><br><span class="line">					v -= <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> t = arr1[flag1 + <span class="number">1</span>].key + arr1[flag1 + <span class="number">2</span>].key;</span><br><span class="line">					<span class="keyword">if</span> (t &gt; arr2[flag2 + <span class="number">1</span>].key) &#123;</span><br><span class="line">						ans += t;</span><br><span class="line">						flag1 += <span class="number">2</span>;</span><br><span class="line">						v -= <span class="number">2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						ans += arr2[++flag2].key;</span><br><span class="line">						v -= <span class="number">2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v &amp;&amp; (flag1 &lt; num1)) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="built_in">min</span>(flag1 + v, num1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = flag1 + <span class="number">1</span>;i &lt;= t;i++) &#123;</span><br><span class="line">			ans += arr1[i].key;</span><br><span class="line">		&#125;</span><br><span class="line">		flag1 = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((v &gt;= <span class="number">2</span>) &amp;&amp; (flag2 &lt; num2)) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = <span class="built_in">min</span>(flag2 + v / <span class="number">2</span>, num2);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = flag2 + <span class="number">1</span>; i &lt;= t;i++) &#123;</span><br><span class="line">				ans += arr2[i].key;</span><br><span class="line">			&#125;</span><br><span class="line">			flag2 = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((flag1 &gt;= <span class="number">2</span>) &amp;&amp; (flag2 &lt; num2) &amp;&amp; ((arr1[flag1].key + arr1[flag1 - <span class="number">1</span>].key) &lt; arr2[flag2 + <span class="number">1</span>].key)) &#123;</span><br><span class="line">		ans -= arr1[flag1].key + arr1[flag1 - <span class="number">1</span>].key;</span><br><span class="line">		ans += arr2[++flag2].key;</span><br><span class="line">		flag1 -= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= flag1;i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr1[i].id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= flag2;i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr2[i].id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF4A(Watermelon)</title>
    <url>/2020/09/02/CF4A/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed $w$ kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.</p>
<p>Pete and Billy are great fans of even numbers, that’s why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that’s why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first (and the only) input line contains integer number $w (1\le w\le 100)$ — the weight of the watermelon bought by the boys.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>需要输出的数能分解成两个偶数，那么该数一定是一个偶数，但是要注意2不满足这一条件，所以要特判一个2</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	cin &gt;&gt; w;</span><br><span class="line">	<span class="keyword">if</span> ((w != <span class="number">2</span>) &amp;&amp; (w % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF5A(Chat Server&#39;s Outgoing Traffic)</title>
    <url>/2020/09/06/CF5A/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Polycarp is working on a new project called “Polychat”. Following modern tendencies in IT, he decided, that this project should contain chat as well. To achieve this goal, Polycarp has spent several hours in front of his laptop and implemented a chat server that can process three types of commands:</p>
<ul>
<li>Include a person to the chat (‘Add’ command).</li>
<li>Remove a person from the chat (‘Remove’ command).</li>
<li>Send a message from a person to all people, who are currently in the chat, including the one, who sends the message (‘Send’ command).</li>
</ul>
<p>Now Polycarp wants to find out the amount of outgoing traffic that the server will produce while processing a particular set of commands.</p>
<p>Polycarp knows that chat server sends no traffic for ‘Add’ and ‘Remove’ commands. When ‘Send’ command is processed, server sends $l$ bytes to each participant of the chat, where $l$ is the length of the message.</p>
<p>As Polycarp has no time, he is asking for your help in solving this problem.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>Input file will contain not more than 100 commands, each in its own line. No line will exceed 100 characters. Formats of the commands will be the following:</p>
<ul>
<li>+&lt;name&gt; for ‘Add’ command.</li>
<li>-&lt;name&gt; for ‘Remove’ command.</li>
<li>&lt;sender_name&gt;:&lt;message_text&gt; for ‘Send’ command.</li>
</ul>
<p>&lt;name&gt; and &lt;sender_name&gt; is a non-empty sequence of Latin letters and digits. &lt;message_text&gt; can contain letters, digits and spaces, but can’t start or end with a space. &lt;message_text&gt; can be an empty line.</p>
<p>It is guaranteed, that input data are correct, i.e. there will be no ‘Add’ command if person with such a name is already in the chat, there will be no ‘Remove’ command if there is no person with such a name in the chat etc.</p>
<p>All names are case-sensitive.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print a single number — answer to the problem.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>每一次输入一串字符串，如果字符串第一个字符为“+”，说明有人加入聊天；如果字符串第一个字符第一个字符为“-”，说明有人退出聊天；如果上述都不是，有人发送信息，那么流量损耗就要加上发送信息的长度$\times $当前在线的人数，最后输出总的流量损耗即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">int</span> num, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin, str)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				num--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> z = str.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">				ans += num * (str.<span class="built_in">size</span>() - z - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF3D(Least Cost Bracket Sequence)</title>
    <url>/2020/09/02/CF3D/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>This is yet another problem on regular bracket sequences.</p>
<p>A bracket sequence is called regular, if by inserting “+” and “1” into it we get a correct mathematical expression. For example, sequences “(())()”, “()” and “(()(()))” are regular, while “)(“, “(()” and “(()))(“ are not. You have a pattern of a bracket sequence that consists of characters “(“, “)” and “?”. You have to replace each character “?” with a bracket so, that you get a regular bracket sequence.</p>
<p>For each character “?” the cost of its replacement with “(“ and “)” is given. Among all the possible variants your should choose the cheapest.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains a non-empty pattern of even length, consisting of characters “(“, “)” and “?”. Its length doesn’t exceed $5·10^{4}$  . Then there follow $m$ lines, where $m$ is the number of characters “?” in the pattern. Each line contains two integer numbers $a_{i}$  and $b_{i}$ $( 1\le a_{i},b_{i}\le$ $ 10^{6})$, where $a_{i}$is the cost of replacing the ii -th character “?” with an opening bracket, and $b_{i}$  — with a closing one.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print the cost of the optimal regular bracket sequence in the first line, and the required sequence in the second.</p>
<p>Print -1, if there is no answer. If the answer is not unique, print any of them.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这道题的思路很简单，首先把所有”?”都修改为”)”，然后从字符串第一位开始遍历，定义一个flag记录遍历情况，如果遇到”(“，flag++,如果遇到”)”，flag–，如果在第i个字符处flag小于0了，那么就从第1个字符到第i个字符中找一个原来是”?”现在是”)”的且原来的的”?”替换成”(“的代价减去”)”的代价最小的位置，将其变为”(“，同时flag+=2；如果找不到，输出-1。处理完这串字符串后，如果flag不等于0，也输出-1。</p>
<p>给自己先埋一个坑，string字符串的读入好像很耗时，我看到很多大佬用了char数组，还得努力学习。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arr</span> &#123;</span></span><br><span class="line">	ll id;</span><br><span class="line">	ll date;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(arr x, arr y) &#123;</span><br><span class="line">		<span class="keyword">return</span> x.date &lt; y.date;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tidai[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	ll f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	ll snum = str.<span class="built_in">size</span>(), num = <span class="number">0</span>, l, r, ans = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>;i &lt; snum;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">			str[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">			tidai[++num].id = i;</span><br><span class="line">			l = <span class="built_in">read</span>();</span><br><span class="line">			r = <span class="built_in">read</span>();</span><br><span class="line">			tidai[num].date = l - r;</span><br><span class="line">			ans += r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(tidai + <span class="number">1</span>, tidai + <span class="number">1</span> + num);</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>;i &lt; snum;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">			flag++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			flag--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (ll j = <span class="number">1</span>;j &lt;= num;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tidai[j].id &lt;= i) &#123;</span><br><span class="line">					str[tidai[j].id] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">					ans += tidai[j].date;</span><br><span class="line">					tidai[j].id = snum * <span class="number">2</span>;</span><br><span class="line">					flag += <span class="number">2</span>;</span><br><span class="line">					f = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (f) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF4B(Before an Exam)</title>
    <url>/2020/09/02/CF4B/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Tomorrow Peter has a Biology exam. He does not like this subject much, but dd days ago he learnt that he would have to take this exam. Peter’s strict parents made him prepare for the exam immediately, for this purpose he has to study not less than $minTime_{i} $and not more than $maxTime_{i}$  hours per each $i$ -th day. Moreover, they warned Peter that a day before the exam they would check how he has followed their instructions.</p>
<p>So, today is the day when Peter’s parents ask him to show the timetable of his preparatory studies. But the boy has counted only the sum of hours $sumTime$ spent him on preparation, and now he wants to know if he can show his parents a timetable sсhedule with $d$ numbers, where each number $sсhedule_{i}$  stands for the time in hours spent by Peter each $i$ -th day on biology studies, and satisfying the limitations imposed by his parents, and at the same time the sum total of all $schedule_{i}$  should equal to sumTime .</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first input line contains two integer numbers$d,sumTimed,sumTime(1\le d\le 30,$ $0\le sumTime\le 240)$ — the amount of days, during which Peter studied, and the total amount of hours, spent on preparation. Each of the following $d$ lines contains two integer numbers $minTime_{i},maxTime_{i}(0\le minTime_{i}\le maxTime_{i}\le 8)$, separated by a space — minimum and maximum amount of hours that Peter could spent in the $i$ -th day.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>In the first line print YES, and in the second line print $d$ numbers (separated by a space), each of the numbers — amount of hours, spent by Peter on preparation in the corresponding day, if he followed his parents’ instructions; or print NO in the unique line. If there are many solutions, print any of them.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>先统计d天的$mintime$和$maxtime$，如果$mintime\le sumtime\le maxtime$，就输出YES，否则输出NO。</p>
<p>如果是YES，我们先$d$天内学习时间全部初始化为当天的$mintime$，如果达不到$sumtime$,就把当天学习时间弄满，然后看达到没有，如此反复。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">30</span>][<span class="number">2</span>], d, s, mi, ma;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; d &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d;i++) &#123;</span><br><span class="line">		cin &gt;&gt; t[i][<span class="number">0</span>] &gt;&gt; t[i][<span class="number">1</span>];</span><br><span class="line">		mi += t[i][<span class="number">0</span>];</span><br><span class="line">		ma += t[i][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((mi &gt; s) || (ma &lt; s)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">		s -= mi;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d;i++) &#123;</span><br><span class="line">			s -= t[i][<span class="number">1</span>] - t[i][<span class="number">0</span>];</span><br><span class="line">			t[i][<span class="number">0</span>] = t[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (s &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				t[i][<span class="number">0</span>] += s;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d;i++) &#123;</span><br><span class="line">			cout &lt;&lt; t[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF3C(Tic-tac-toe)</title>
    <url>/2020/09/01/CF3C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Certainly, everyone is familiar with tic-tac-toe game. The rules are very simple indeed. Two players take turns marking the cells in a $3\times 3$ grid (one player always draws crosses, the other — noughts). The player who succeeds first in placing three of his marks in a horizontal, vertical or diagonal line wins, and the game is finished. The player who draws crosses goes first. If the grid is filled, but neither Xs, nor 0s form the required line, a draw is announced.</p>
<p>You are given a $3\times 3$ grid, each grid cell is empty, or occupied by a cross or a nought. You have to find the player (first or second), whose turn is next, or print one of the verdicts below:</p>
<ul>
<li>illegal — if the given board layout can’t appear during a valid game;</li>
<li>the first player won — if in the given board layout the first player has just won;</li>
<li>the second player won — if in the given board layout the second player has just won;</li>
<li>draw — if the given board layout has just let to a draw.<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1>The input consists of three lines, each of the lines contains characters “.”, “X” or “0” (a period, a capital letter X, or a digit zero).<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1>Print one of the six verdicts: first, second, illegal, the first player won, the second player won or draw.<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1>首先，必须要有一个判断输赢的函数。</li>
</ul>
<p>如果某一方赢了且双方合法，则输出输赢结果；</p>
<p>如果两方都没有输赢，但是棋盘满了，就输出平局，如果没满，就输出下一步该谁下棋了。</p>
<p>麻烦的是判断何时非法：</p>
<ul>
<li><p>first走的棋数比second走的棋数多的数大于1</p>
</li>
<li><p>second走的棋数比first走的棋数多</p>
</li>
<li><p>双方都赢了</p>
</li>
<li><p>first赢了，但他走的棋数减去second走的棋数不等于1</p>
</li>
<li><p>second赢了，但他走的棋数不等于first走的棋数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>], num1, num2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">win</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag1 = <span class="number">0</span>, flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">0</span>][<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">0</span>][<span class="number">1</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">2</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">2</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">1</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">1</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">2</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">2</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">	flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">2</span>) &amp;&amp; (arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">	flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (flag1 + flag2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">char</span> c;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">				arr[i][j] = <span class="number">1</span>;</span><br><span class="line">				num1++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">					arr[i][j] = <span class="number">2</span>;</span><br><span class="line">					num2++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> w = <span class="built_in">win</span>();</span><br><span class="line">	<span class="keyword">if</span> (w == <span class="number">3</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;illegal&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (w == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (((num1 - num2) &gt; <span class="number">1</span>) || (num1 &lt; num2)) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;illegal&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (num1 + num2 == <span class="number">9</span>) &#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;draw&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">						cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (((num1 - num2) != <span class="number">1</span>)) &#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;illegal&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;the first player won&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> ((num1 != num2))&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;illegal&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;the second player won&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF4C(Registration system)</title>
    <url>/2020/09/02/CF4C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>A new e-mail service “Berlandesk” is going to be opened in Berland in the near future. The site administration wants to launch their project as soon as possible, that’s why they ask you to help. You’re suggested to implement the prototype of site registration system. The system should work on the following principle.</p>
<p>Each time a new user wants to register, he sends to the system a request with his name. If such a name does not exist in the system database, it is inserted into the database, and the user gets the response OK, confirming the successful registration. If the name already exists in the system database, the system makes up a new user name, sends it to the user as a prompt and also inserts the prompt into the database. The new name is formed by the following rule. Numbers, starting with 1, are appended one after another to name (name1, name2, …), among these numbers the least $i$ is found so that name $i$ does not yet exist in the database.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains number $n(1&lt;=n&lt;=10^{5})$. The following nn lines contain the requests to the system. Each request is a non-empty line, and consists of not more than 32 characters, which are all lowercase Latin letters.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print n lines, which are system responses to the requests: OK in case of successful registration, or a prompt with a new name, if the requested name is already taken.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>map强无敌！</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt;mymap;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		string name;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		<span class="keyword">if</span> ((++mymap[name]) == <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; name &lt;&lt; (mymap[name] - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF4D(Mysterious Present)</title>
    <url>/2020/09/06/CF4D/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Peter decided to wish happy birthday to his friend from Australia and send him a card. To make his present more mysterious, he decided to make a chain. Chain here is such a sequence of envelopes $A = { a_{1},a_{2},…,a_{n}}$, where the width and the height of the $i$ -th envelope is strictly higher than the width and the height of the $(i-1)$ -th envelope respectively. Chain size is the number of envelopes in the chain.</p>
<p>Peter wants to make the chain of the maximum size from the envelopes he has, the chain should be such, that he’ll be able to put a card into it. The card fits into the chain if its width and height is lower than the width and the height of the smallest envelope in the chain respectively. It’s forbidden to turn the card and the envelopes.</p>
<p>Peter has very many envelopes and very little time, this hard task is entrusted to you.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains integers $n ,w  , h ( 1\le n\le 5000 , 1\le w,h\le 10^{6}) $— amount of envelopes Peter has, the card width and height respectively. Then there follow $n$ lines, each of them contains two integer numbers $w_{i}$ and $h_{i}$  — width and height of the $i$ -th envelope $( 1\le w_{i},h_{i}\le 10^{6})$.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>In the first line print the maximum chain size. In the second line print the numbers of the envelopes (separated by space), forming the required chain, starting with the number of the smallest envelope. Remember, please, that the card should fit into the smallest envelope. If the chain of maximum size is not unique, print any of the answers.</p>
<p>If the card does not fit into any of the envelopes, print number 0 in the single line.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题有些小细节好能卡人啊，它要求是严格单调递增的，就意味着序列中相邻物品无论是长还是宽都不能相等，然后是一个二维下的比较，难度up up。</p>
<p>突然想起自己做过的P1020，那道题里其实隐藏了二维比较-时间和高度，只不过人家把时间都预先排列好了，那么我们也可以这么处理输入的物品中满足$ w\le w_i,h\le h_i$的物品，将它们按照宽度的升序排列一遍(sort函数真好用)，注意其中可能有些物体的宽度是相等的，我们在这部分物体里按照高度的降序排列一遍，为什么用降序后面会说。</p>
<p>处理完之后，把满足条件并且排好序的物体试探性一一加入目标序列</p>
<ul>
<li>如果序列为空或者将要加入的物体的宽度和高度大于序列尾端的物体的宽度和高度，那么加入就完事了</li>
<li>如果序列不为空，且将要加入的物体的宽度和高度等于序列尾端的物体的宽度和高度，那么直接continue完事，因为这相当于是一个物体出现了两次</li>
<li>如果序列不为空，将要加入的物体的宽度等于序列尾端的物体的宽度，但待加入的物体的高度小于序列尾端的物体的高度，那么就试探性的把这个物体替换掉序列中第一个高度大于等于它的物体</li>
<li>如果序列不为空，将要加入的物体的宽度大于序列尾端的物体的宽度，但待加入的物体的高度等于序列尾端物体的高度，那么就continue，因为把它放入序列不利于序列的变长</li>
<li>如果序列不为空，将要加入的物体的宽度大于序列尾端的物体的宽度，但待加入的物体的高度小于序列尾端物体的高度，那么就试探性的把这个物体替换掉序列中第一个高度大于等于它的物体</li>
</ul>
<p>在把物体试探性加入序列过程中，有些物体的试探性替代并不会使得序列变长，所以我们可以给每个物体添加一个指针指向序列中的上一个物体，如果上一个物体被试探性的替代了，那么后面可以由这个指针还原，而在序列因为试探性替代的物体而变长的话，这种还原性就被破坏了。</p>
<p>最后解释一下为什么前面预处理的时候，当宽度相等的情况下，高度要降序排序，假设还是升序排序，如果两个宽度相等的物体都要去序列中试探性替代，但是巧合的位置相邻，那么后加入的那个物体的指针就会指向先加入的物体，再巧合的由于后加入的那个物体引起了序列长度的变化，那么也会强制的把前一个物体计入序列中，这是不对的。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> w = <span class="number">0</span>, h = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">	node* last = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(node a, node b) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((a.w &lt; b.w) || ((a.w == b.w) &amp;&amp; (a.h &gt; b.h)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;arr[<span class="number">5001</span>];</span><br><span class="line">node * line[<span class="number">5001</span>];</span><br><span class="line"><span class="keyword">int</span> n, num = <span class="number">0</span>, W, H, len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower</span><span class="params">(node a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = len;</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> b = line[(l + r) / <span class="number">2</span>]-&gt;h;</span><br><span class="line">		<span class="keyword">if</span> (b &gt;= a.h) &#123;</span><br><span class="line">			r = (l + r) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = (l + r) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (line[l]-&gt;h &gt;= a.h) &#123;</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	W = <span class="built_in">read</span>();</span><br><span class="line">	H = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span> ((a &gt; W) &amp;&amp; (b &gt; H)) &#123;</span><br><span class="line">			arr[++num].id = i;</span><br><span class="line">			arr[num].w = a;</span><br><span class="line">			arr[num].h = b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + num);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = arr[i].w;</span><br><span class="line">		<span class="keyword">int</span> b = arr[i].h;</span><br><span class="line">		<span class="keyword">if</span> ((line[len] != <span class="literal">nullptr</span>) &amp;&amp; (a == (line[len]-&gt;w))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (b == line[len]-&gt;h) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> p = <span class="built_in">lower</span>(arr[i]);</span><br><span class="line">				arr[i].last = line[p - <span class="number">1</span>];</span><br><span class="line">				line[p] = &amp;(arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ((line[len] == <span class="literal">nullptr</span>) || (b &gt; line[len]-&gt;h)) &#123;</span><br><span class="line">				arr[i].last = line[len];</span><br><span class="line">				line[++len] = &amp;(arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (b == line[len]-&gt;h) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> p = <span class="built_in">lower</span>(arr[i]);</span><br><span class="line">					arr[i].last = line[p - <span class="number">1</span>];</span><br><span class="line">					line[p] = &amp;(arr[i]);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (len) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len;i &gt; <span class="number">1</span>;i--) &#123;</span><br><span class="line">			line[i - <span class="number">1</span>] = line[i]-&gt;last;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) &#123;</span><br><span class="line">			cout &lt;&lt; line[i]-&gt;id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF5B(Center Alignment)</title>
    <url>/2020/09/06/CF5B/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Almost every text editor has a built-in function of center text alignment. The developers of the popular in Berland text editor «Textpad» decided to introduce this functionality into the fourth release of the product.</p>
<p>You are to implement the alignment in the shortest possible time. Good luck!</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The input file consists of one or more lines, each of the lines contains Latin letters, digits and/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Format the given text, aligning it center. Frame the whole text with characters «*» of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题也太水了，简单过，可以用string str(n,’char’)的方式去加速for输出一串字符相同的字符串</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string arr[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> maxn, num, len[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin, arr[num])) &#123;</span><br><span class="line">		len[num] = arr[num].<span class="built_in">size</span>();</span><br><span class="line">		maxn = <span class="built_in">max</span>(maxn, len[num++]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">s1</span><span class="params">(maxn + <span class="number">2</span>, <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> l = (maxn - len[i]) / <span class="number">2</span>, r = l;</span><br><span class="line">		<span class="keyword">if</span> ((maxn - len[i]) % <span class="number">2</span>) &#123;</span><br><span class="line">			l += flag;</span><br><span class="line">			r += !flag;</span><br><span class="line">			flag = !flag;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">string <span class="title">s</span><span class="params">(l, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">		cout &lt;&lt; s;</span><br><span class="line">		cout &lt;&lt; arr[i];</span><br><span class="line">		<span class="function">string <span class="title">t</span><span class="params">(r, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">		cout &lt;&lt; t;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(maxn + <span class="number">2</span>, <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; s2 ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF5C(Longest Regular Bracket Sequence)</title>
    <url>/2020/09/07/CF5C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>This is yet another problem dealing with regular bracket sequences.</p>
<p>We should remind you that a bracket sequence is called regular, if by inserting «+» and «1» into it we can get a correct mathematical expression. For example, sequences «(())()», «()» and «(()(()))» are regular, while «)(», «(()» and «(()))(» are not.</p>
<p>You are given a string of «(» and «)» characters. You are to find its longest substring that is a regular bracket sequence. You are to find the number of such substrings as well.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line of the input file contains a non-empty string, consisting of «(» and «)» characters. Its length does not exceed $10^{6}$.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print the length of the longest substring that is a regular bracket sequence, and the number of such substrings. If there are no such substrings, write the only line containing “0 1”.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>对于每一个”)”，都应该与离它最近的”(“匹配，对于还没有匹配的”(“，可以暂时用一个栈记录下来。每匹配一次，都要记录下来这次匹配的长度和能否与其它匹配连接在一起，更新最大值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1000001</span>], len, maxn, cot = <span class="number">1</span>, mystack[<span class="number">1000001</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	len = str. <span class="built_in">size</span>();</span><br><span class="line">	str = <span class="string">&quot; &quot;</span> + str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">			mystack[++n] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (n) &#123;</span><br><span class="line">				num[i] = i - mystack[n] + <span class="number">1</span> + num[mystack[n] - <span class="number">1</span>];</span><br><span class="line">				n--;</span><br><span class="line">				<span class="keyword">if</span> (num[i] &gt; maxn) &#123;</span><br><span class="line">					maxn = num[i];</span><br><span class="line">					cot = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (num[i] == maxn) &#123;</span><br><span class="line">						cot++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; maxn &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cot;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF5D(Follow Traffic Rules)</title>
    <url>/2020/09/08/CF5D/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road’s traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.</p>
<p>It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of $a$ $km/h ^{2}$, and has maximum speed of $v$ $km/h$. The road has the length of $l$ km, and the speed sign, limiting the speed to $w$ km/h, is placed $d$ km $( 1\le d &lt; l )$ away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.</p>
<p>The car can enter Bercouver at any speed.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line of the input file contains two integer numbers $a$ and $v$ $( 1\le a,v\le 10000 )$. The second line contains three integer numbers $l$ , $d$ and $w$ $( 2\le l\le 10000 ; 1\le d &lt; l ; 1\le $ $ w\le 10000 )$.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这是一道物理题，不难，但是有点繁琐，弄清楚每种情况就简单了</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> a, v, l, d, w, t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; v &gt;&gt; l &gt;&gt; d &gt;&gt; w;</span><br><span class="line">	<span class="keyword">if</span> (w &gt;= v) &#123;</span><br><span class="line">		<span class="keyword">if</span> (((v*v) / (<span class="number">2</span> * a) &lt;= l)) &#123;</span><br><span class="line">			t = v / (<span class="number">2</span> * a) + l / v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			t = <span class="built_in">sqrt</span>(<span class="number">2</span> * l / a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (((w*w) / (<span class="number">2</span> * a)) &lt;= d) &#123;</span><br><span class="line">			<span class="keyword">if</span> (((<span class="number">2</span> * v*v - w * w) / (<span class="number">2</span> * a)) &lt;= d) &#123;</span><br><span class="line">				t += (v - w) / a + d / v + (w*w) / (<span class="number">2</span> * a*v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				t += (<span class="built_in">sqrt</span>(<span class="number">2</span> * w*w + <span class="number">4</span> * a*d) - w) / a;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (((v*v - w * w) / (<span class="number">2</span> * a)) &lt;= (l - d)) &#123;</span><br><span class="line">				t += (v - w) / a + (l - d) / v + (w*w - v * v) / (<span class="number">2</span> * a*v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				t += (<span class="built_in">sqrt</span>(<span class="number">2</span> * a*(l - d) + w * w) - w) / a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			t += <span class="built_in">sqrt</span>(<span class="number">2</span> * d / a);</span><br><span class="line">			w = <span class="built_in">sqrt</span>(<span class="number">2</span> * a*d);</span><br><span class="line">			<span class="keyword">if</span> (((v*v - w * w) / (<span class="number">2</span> * a)) &lt;= (l - d)) &#123;</span><br><span class="line">				t += (v - w) / a + (l - d) / v + (w*w - v * v) / (<span class="number">2</span> * a*v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				t += (<span class="built_in">sqrt</span>(<span class="number">2</span> * a*(l - d) + w * w) - w) / a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; t;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF5E(Bindian Signalizing)</title>
    <url>/2020/09/18/CF5E/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Everyone knows that long ago on the territory of present-day Berland there lived Bindian tribes. Their capital was surrounded by $n$ hills, forming a circle. On each hill there was a watchman, who watched the neighbourhood day and night.</p>
<p>In case of any danger the watchman could make a fire on the hill. One watchman could see the signal of another watchman, if on the circle arc connecting the two hills there was no hill higher than any of the two. As for any two hills there are two different circle arcs connecting them, the signal was seen if the above mentioned condition was satisfied on at least one of the arcs. For example, for any two neighbouring watchmen it is true that the signal of one will be seen by the other.</p>
<p>An important characteristics of this watch system was the amount of pairs of watchmen able to see each other’s signals. You are to find this amount by the given heights of the hills.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line of the input data contains an integer number $n ( 3&lt;=n&lt;=10^{6}), n$ — the amount of hills around the capital. The second line contains $n$ numbers — heights of the hills in clockwise order. All height numbers are integer and lie between $1$ and $10^{9}$.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print the required amount of pairs.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>首先在实际中，这是一个环，如果不加以判断找一个断点将其断开成链的形式，那么可能会有两个可以互相观察到的点跨过这个断点，这在编程上会带来不必要的麻烦。我们可以选择最大的那个点作为链的头节点，那么就不会有一高一低两个可以互相观察到的点越过链头，那么两个相同高度的点怎么算呢？这个后面再说。用单调栈的算法求出每个数左边第一个大于它的数的下标和右边第一个数的下标，如果这两个数都能求出来且不相同，则ans+=2，如果求出来了但这两个数相同或者只求出了一个数，则ans+=1,如果两个数都求不出来，那么就不进行操作。然后再来讲讲相同高度的点怎么处理。<br>比如有5个点，分别为5，5，3，3，5，那么我们就统计每个数到上一个大于它的数或0位置的数之间等于他的数的个数，第一个的个数为0，第二个的个数为1，第三个的个数为0，第四个5的个数为1，第五个5的个数为2，那么ans就把这些数字加起来。<br>最后就是输出ans了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> arrh[<span class="number">1000001</span>], num, lef[<span class="number">1000001</span>], rig[<span class="number">1000001</span>], cnt[<span class="number">1000001</span>], p, arr[<span class="number">1000001</span>], maxn;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;l, r;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	num = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">		arr[i] = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; maxn) &#123;</span><br><span class="line">			maxn = arr[i];</span><br><span class="line">			p = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">		arrh[i] = arr[(i + p) % num];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> ((!l.<span class="built_in">empty</span>()) &amp;&amp; (arrh[l.<span class="built_in">top</span>()] &lt; arrh[i])) &#123;</span><br><span class="line">			l.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!l.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i) != l.<span class="built_in">top</span>()) &#123;</span><br><span class="line">				lef[i] = l.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (arrh[i] == arrh[l.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">					cnt[i] = cnt[l.<span class="built_in">top</span>()] + <span class="number">1</span>;</span><br><span class="line">					lef[i] = lef[lef[i] - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				l.<span class="built_in">push</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l.<span class="built_in">push</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = num;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">while</span> ((!r.<span class="built_in">empty</span>()) &amp;&amp; (arrh[r.<span class="built_in">top</span>()] &lt;= arrh[i%num])) &#123;</span><br><span class="line">			r.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!r.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i%num) != r.<span class="built_in">top</span>()) &#123;</span><br><span class="line">				rig[i%num] = r.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">				r.<span class="built_in">push</span>(i%num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			r.<span class="built_in">push</span>(i%num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lef[i] &amp;&amp; rig[i] &amp;&amp; (lef[i] != rig[i])) &#123;</span><br><span class="line">			ans += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (lef[i] || rig[i]) &#123;</span><br><span class="line">				ans += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += cnt[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF6A(Triangle)</title>
    <url>/2020/09/19/CF6A/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Johnny has a younger sister Anne, who is very clever and smart. As she came home from the kindergarten, she told his brother about the task that her kindergartener asked her to solve. The task was just to construct a triangle out of four sticks of different colours. Naturally, one of the sticks is extra. It is not allowed to break the sticks or use their partial length. Anne has perfectly solved this task, now she is asking Johnny to do the same.</p>
<p>The boy answered that he would cope with it without any difficulty. However, after a while he found out that different tricky things can occur. It can happen that it is impossible to construct a triangle of a positive area, but it is possible to construct a degenerate triangle. It can be so, that it is impossible to construct a degenerate triangle even. As Johnny is very lazy, he does not want to consider such a big amount of cases, he asks you to help him.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line of the input contains four space-separated positive integer numbers not exceeding 100 — lengthes of the sticks.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Output TRIANGLE if it is possible to construct a non-degenerate triangle. Output SEGMENT if the first case cannot take place and it is possible to construct a degenerate triangle. Output IMPOSSIBLE if it is impossible to construct any triangle. Remember that you are to use three sticks. It is not allowed to break the sticks or use their partial length.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>先将四个数从小到大排列一遍，这四个数中，能组成三角形或退化三角形的就只有可能是前三个数或后三个数，一一判断下就可以了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">		arr[i] = <span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr, arr + <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span> ((arr[<span class="number">0</span>] + arr[<span class="number">1</span>] &gt; arr[<span class="number">2</span>]) || (arr[<span class="number">1</span>] + arr[<span class="number">2</span>] &gt; arr[<span class="number">3</span>])) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;TRIANGLE&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((arr[<span class="number">0</span>] + arr[<span class="number">1</span>] == arr[<span class="number">2</span>]) || (arr[<span class="number">1</span>] + arr[<span class="number">2</span>] == arr[<span class="number">3</span>])) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;SEGMENT&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF6B(President&#39;s Office)</title>
    <url>/2020/09/21/CF6B/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>President of Berland has a very vast office-room, where, apart from him, work his subordinates. Each subordinate, as well as President himself, has his own desk of a unique colour. Each desk is rectangular, and its sides are parallel to the office walls. One day President decided to establish an assembly, of which all his deputies will be members. Unfortunately, he does not remember the exact amount of his deputies, but he remembers that the desk of each his deputy is adjacent to his own desk, that is to say, the two desks (President’s and each deputy’s) have a common side of a positive length.</p>
<p>The office-room plan can be viewed as a matrix with $n$ rows and $m$ columns. Each cell of this matrix is either empty, or contains a part of a desk. An uppercase Latin letter stands for each desk colour. The «period» character («.») stands for an empty cell.</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains two separated by a space integer numbers $n , m ( 1\le n,m\le 100 )$ — the length and the width of the office-room, and $c$ character — the President’s desk colour. The following $n$ lines contain $m$ characters each — the office-room description. It is guaranteed that the colour of each desk is unique, and each desk represents a continuous subrectangle of the given matrix. All colours are marked by uppercase Latin letters.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print the only number — the amount of President’s deputies.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>暴力搜索，没啥好说的，还好不同桌子不同色</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> c, s[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; se;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i][j] == c) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i][j + <span class="number">1</span>] != c &amp;&amp; s[i][j + <span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span>&amp;&amp;j + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">					se.<span class="built_in">insert</span>(s[i][j + <span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (s[i + <span class="number">1</span>][j] != c &amp;&amp; s[i + <span class="number">1</span>][j] != <span class="string">&#x27;.&#x27;</span>&amp;&amp;i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">					se.<span class="built_in">insert</span>(s[i + <span class="number">1</span>][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (s[i][j - <span class="number">1</span>] != c &amp;&amp; s[i][j - <span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span>&amp;&amp;j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					se.<span class="built_in">insert</span>(s[i][j - <span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (s[i - <span class="number">1</span>][j] != c &amp;&amp; s[i - <span class="number">1</span>][j] != <span class="string">&#x27;.&#x27;</span>&amp;&amp;i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					se.<span class="built_in">insert</span>(s[i - <span class="number">1</span>][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; se.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>CF6C(Alice, Bob and Chocolate)</title>
    <url>/2020/09/21/CF6C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Alice and Bob like games. And now they are ready to start a new game. They have placed $n$ chocolate bars in a line. Alice starts to eat chocolate bars one by one from left to right, and Bob — from right to left. For each chocololate bar the time, needed for the player to consume it, is known (Alice and Bob eat them with equal speed). When the player consumes a chocolate bar, he immediately starts with another. It is not allowed to eat two chocolate bars at the same time, to leave the bar unfinished and to make pauses. If both players start to eat the same bar simultaneously, Bob leaves it to Alice as a true gentleman.</p>
<p>How many bars each of the players will consume?</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>The first line contains one integer $n (1\le n\le 10^{5})$ — the amount of bars on the table. The second line contains a sequence $t_{1},t_{2},…,t_{n}  ( 1\le t_{i}\le 1000)$, where $t_{i}$is the time (in seconds) needed to consume the $i$ -th bar (in the order from left to right).</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>Print two numbers $a$ and $b$ , where $a$ is the amount of bars consumed by Alice, and $b$ is the amount of bars consumed by Bob.</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>又是一道水题</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> num, time_a, time_b, time[<span class="number">100001</span>], num_a, num_b;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	num = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">		time[i] = <span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((num_a + num_b) &lt; num) &#123;</span><br><span class="line">		<span class="keyword">if</span> (time_a &lt;= time_b) &#123;</span><br><span class="line">			time_a += time[num_a++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			time_b += time[num - <span class="number">1</span> - (num_b++)];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; num_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>CodeForce</tag>
      </tags>
  </entry>
  <entry>
    <title>塞瓦定理(Ceva&#39;s theorem)</title>
    <url>/2021/08/31/Ceva/</url>
    <content><![CDATA[<h1 id="定理描述"><a href="#定理描述" class="headerlink" title="定理描述"></a>定理描述</h1><p>在$\Delta ABC$内任取一点$O$，延长$AO,BO,CO$分别交对边于$D,E,F$，则</p>
<p>$|AF|\times |BD|\times |CE|=|FB|\times |DC|\times |EA|$</p>
<p><img src="https://i.loli.net/2021/08/31/bnAINFxZ5ftMiDy.png" alt="Ceva.png"></p>
<span id="more"></span>
<h1 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h1><p>$\frac{|AF|}{|BF|}\times \frac{|BD|}{|CD|}\times \frac{|CE|}{|AE|}$</p>
<p>$=\frac{\frac{|AF|}{|OF|}}{\frac{|BF|}{|OF|}}\times \frac{\frac{|BD|}{|OD|}}{\frac{|CD|}{|OD|}}\times \frac{\frac{|CE|}{|OE|}}{\frac{|AE|}{|OE|}}$</p>
<p>$=\frac{\frac{sin\angle AOF}{sin\angle OAF}}{\frac{sin\angle BOF}{sin\angle OBF}}\times \frac{\frac{sin\angle BOD}{sin\angle OBD}}{\frac{sin\angle COD}{sin\angle OCD}}\times \frac{\frac{sin\angle COE}{sin\angle OCE}}{\frac{sin\angle AOE}{sin\angle OAE}}$</p>
<p>$\because \angle FOB=\angle EOC,\angle BOD=\angle AOE,\angle AOF=\angle COD$</p>
<p>$\therefore sin\angle FOB=sin\angle EOC,sin\angle BOD=sin\angle AOE,sin\angle AOF=sin\angle COD$</p>
<p>$\therefore \text{原式}=\frac{sin\angle OBF}{sin\angle OAF}\times \frac{sin\angle OCD}{sin\angle OBD}\times \frac{sin\angle OAE}{sin\angle OCE}$</p>
<p>$=\frac{|OA|}{|OB|}\times \frac{|OB|}{|OC|}\times \frac{|OC|}{|OA|}$</p>
<p>$=1$</p>
<p>$\therefore |AF|\times |BD|\times |CE|=|FB|\times |DC|\times |EA|$</p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Theorem</tag>
      </tags>
  </entry>
  <entry>
    <title>Dreamwevear网页设计</title>
    <url>/2022/03/17/Dreamwevear%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="主要介绍"><a href="#主要介绍" class="headerlink" title="主要介绍"></a>主要介绍</h1><p>这门课程是我在大学开始时选的课程，如成绩单所示，这一门课的性质是任选。我记得我刚开始学习这门课程是为了设计一个自己的网页，在课程上，老师带领我们学习了有关Dreamwevaer的许多内容。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>用标签代表一部分内容的开始，用带有斜杠的相同标签代表着该部分内容的结束</li>
<li>没有缩进，不像python那样能自动识别代码的结束</li>
<li>运行是静态的，不会进行计算或者其它操作</li>
</ul>
<h1 id="必要的标签"><a href="#必要的标签" class="headerlink" title="必要的标签"></a>必要的标签</h1><ul>
<li>html</li>
<li>head</li>
<li>title</li>
<li>body</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>梅涅劳斯定理(Menelaus)</title>
    <url>/2021/08/30/Menelaus/</url>
    <content><![CDATA[<h1 id="定理描述"><a href="#定理描述" class="headerlink" title="定理描述"></a>定理描述</h1><p>当一条直线交$\Delta ABC$三边$BC、AC、AB$于点$D、E、F$时，有$|AF|\times |BD|\times |CE|=|BF|\times |CD|\times |AE|$</p>
<p><img src="https://i.loli.net/2021/08/30/5Qo24Pc6x8Fmpde.png" alt="Menelaus.png"></p>
<span id="more"></span>
<h1 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h1><p>$\because \frac{|AF|}{|BF|}\times \frac{|BD|}{|CD|}\times \frac{|CE|}{|AE|}=\frac{|AF|}{|AE|}\times \frac{|BD|}{|BF|}\times \frac{|CE|}{|CD|}$</p>
<p>$And\because \frac{|AF|}{|AE|}\times \frac{|BD|}{|BF|}\times \frac{|CE|}{|CD|}=\frac{sin\angle AEF}{sin\angle AFE}\times \frac{sin\angle BFD}{sin\angle BDF}\times \frac{sin\angle CDE}{sin\angle CED}$</p>
<p>$And\because \frac{sin\angle AEF}{sin\angle AFE}\times \frac{sin\angle BFD}{sin\angle BDF}\times \frac{sin\angle CDE}{sin\angle CED}=1$</p>
<p>$\therefore |AF|\times |BD|\times |CE|=|BF|\times |CD|\times |AE|$</p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Theorem</tag>
      </tags>
  </entry>
  <entry>
    <title>P1000（超级玛丽游戏）</title>
    <url>/2020/08/13/P1000/</url>
    <content><![CDATA[<p>才发现洛谷有P1000这题，“万事开头难”，彩蛋之题啊</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;                ********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;               ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;               ####....#.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;             #..###.....##....&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;             ###.......######              ###            ###&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;                ...........               #...#          #...#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;               ##*#######                 #.#.#          #.#.#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;            ####*******######             #.#.#          #.#.#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;           ...#***.****.*###....          #...#          #...#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;           ....**********##.....           ###            ###&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;           ....****    *****....&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;             ####        ####&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;           ######        ######&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;##############################################################&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;#...#......#.##...#......#.##...#......#.##------------------#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;###########################################------------------#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;#..#....#....##..#....#....##..#....#....#####################&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;##########################################    #----------#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;#.....#......##.....#......##.....#......#    #----------#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;##########################################    #----------#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;##########################################    ############&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1001（A+B Problem）</title>
    <url>/2020/08/14/P1001/</url>
    <content><![CDATA[<p>这一题是A+B题，作为一个入门选手，肯定都会，简简单单的<code>Cout&lt;&lt;a+b</code>之后，手贱点开了题解，然后颤颤巍巍地关闭网页。   </p>
<p>唉，洛谷的大佬们太不友好了，给我来了一个下马威，不过这让我认识到了自己的渺小，人外有人，山外有山，晚辈自当奋发图强，超越就是最好的致敬。</p>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1002（过河卒）</title>
    <url>/2020/08/14/P1002/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。   </p>
<p>棋盘用坐标表示，A 点 (0, 0)、B 点 (n, m)，同样马的位置坐标是需要给出的。   </p>
<p>现在要求你计算出卒从 A 点能够到达 B 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一行四个正整数，分别表示 B 点坐标和马的坐标。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个整数，表示所有的路径条数。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 100 % 的数据，$ 1 \le n,m \le 20 ,0 \le $ 马的坐标 $ \le 20 $</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这一道题，我做了大概半天，感悟良多，其中，最重要的是感叹自己基础不够，没有把这个问题考虑透彻。   </p>
<p>参考了大佬们的思路，磕磕碰碰总算写出来了。   </p>
<p>在编程中，最简单又最容易碰到的问题是数组越界，可是我却没有考虑清楚，还有马的位置会影响棋盘边界能否让卒落脚，这是一个简单的问题，却也是复杂的问题。   </p>
<p>最开始我的写法是用一个30*30的数组暴力遍历所有棋盘上的点，但是我后来想到卒只能向下或向右移动，也就是说B点以后的点是影响不了B点的值得，所以只用考虑B点和A点围城的一个矩形的范围内的棋点。   </p>
<p>同时，由于第一行的数据在计算完第二行的数据之后就没用了，第二行计算完第三行的数据就没用了，所以可以采用滚动数组的方式去遍历整个棋盘。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ull f[<span class="number">23</span>];</span><br><span class="line"><span class="keyword">bool</span> s[<span class="number">23</span>][<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bx, by, mx, my;</span><br><span class="line">	cin &gt;&gt; bx &gt;&gt; by &gt;&gt; mx &gt;&gt; my;</span><br><span class="line">	bx+=<span class="number">2</span>;</span><br><span class="line">	by+=<span class="number">2</span>;</span><br><span class="line">	mx+=<span class="number">2</span>;</span><br><span class="line">	my+=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> x[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> y[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">8</span>;i++) &#123;</span><br><span class="line">		s[mx + x[i]][my + y[i]] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= bx;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= by;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i][j]) &#123;</span><br><span class="line">				f[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				f[j] +=f[j<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[by];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1003（铺地毯）</title>
    <url>/2020/08/14/P1003/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n 张地毯，编号从 1 到 n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。   </p>
<p>地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入共 n + 2 行。   </p>
<p>第一行，一个整数 n，表示总共有 n 张地毯。   </p>
<p>接下来的 n 行中，第 i+1 行表示编号 i 的地毯的信息，包含四个整数 a ,b ,g ,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 (a, b) 以及地毯在 x 轴和 y 轴方向的长度。   </p>
<p>第 n + 2 行包含两个整数 x 和 y，表示所求的地面的点的坐标 (x, y)。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出共 1 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 -1。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 $30% $ 的数据，有 $n \le 2$。  </p>
<p>对于 $50% $的数据，$0 \le a, b, g, k \le 100$。  </p>
<p>对于 $100% $ 的数据，有 $0 \le n \le 10^4 , 0 \le a, b, g, k \le {10}^5 $。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这一题做的我有点飘啊，主要思想就是从编号比较大的先开始遍历，一次过，虽然可能会有人会吐槽我做的太简单了，本来想用栈的，但是感觉栈就是杀鸡用牛刀了。  </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> ** sj = <span class="keyword">new</span> <span class="keyword">int</span> *[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		sj[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n ;i++) &#123;</span><br><span class="line">		cin &gt;&gt; sj[i][<span class="number">0</span>] &gt;&gt; sj[i][<span class="number">1</span>] &gt;&gt; sj[i][<span class="number">2</span>] &gt;&gt; sj[i][<span class="number">3</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">1</span>);i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((x &gt;= sj[i][<span class="number">0</span>])&amp;&amp;(y&gt;=sj[i][<span class="number">1</span>])&amp;&amp;(x&lt;=(sj[i][<span class="number">0</span>]+sj[i][<span class="number">2</span>]))&amp;&amp;(y&lt;=(sj[i][<span class="number">1</span>]+sj[i][<span class="number">3</span>]))) &#123;</span><br><span class="line">			cout &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1004（方格取数）</title>
    <url>/2020/08/14/P1004/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。   </p>
<p>某人从图的左上角的 A 点出发，可以向下行走，也可以向右走，直到到达右下角的 B 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0）。   </p>
<p>此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入的第一行为一个整数 N（表示 N×N 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 0 表示输入结束。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>只需输出一个整数，表示 2 条路径上取得的最大的和。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这一题我在做之前是看了题解的，但是好吓人，有人用了4维数组，特别恐怖。   </p>
<p>时间复杂度姑且不计，n^4空间复杂度就太恐怖了，但是注意到题目的一个性质，就是每个点的值只与前面一次遍历到的点有关，可以再次采用滚动数组的方法。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll f[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">ll map[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		ll x, y, z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		<span class="keyword">if</span> ((!x) &amp;&amp; (!y) &amp;&amp; (!z)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		map[x++][y++] = z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l &lt;= n * <span class="number">2</span>;l++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ii = l - <span class="number">1</span>;ii &gt;= <span class="number">1</span>;ii--)&#123;</span><br><span class="line">				<span class="keyword">int</span> j = l - i;</span><br><span class="line">				<span class="keyword">int</span> jj = l - ii;</span><br><span class="line">				<span class="keyword">if</span> ((i &lt;= n) &amp;&amp; (j &lt;= n) &amp;&amp; (ii &lt;= n) &amp;&amp; (jj &lt;= n)) &#123;</span><br><span class="line">					f[i][ii] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[i][ii], f[i - <span class="number">1</span>][ii - <span class="number">1</span>]), <span class="built_in">max</span>(f[i - <span class="number">1</span>][ii], f[i][ii - <span class="number">1</span>])) + map[i][j];</span><br><span class="line">					f[i][ii] += map[ii][jj] * (i != ii);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1006（传纸条）</title>
    <url>/2020/08/14/P1006/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 (1,1)，小轩坐在矩阵的右下角，坐标 (m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。   </p>
<p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。   </p>
<p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 0 表示），可以用一个 [0,100] 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有两个用空格隔开的整数 m 和 n，表示班里有 m 行 n列。   </p>
<p>接下来的 m 行是一个 $m\times n$ 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度。每行的 n 个整数之间用空格隔开。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 $30%$ 的数据，$1 \le m,n \le 10$； 对于 $ 100% $ 的数据满足：$ 1 \le m,n \le 50 $</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题比较重要的一个点是每个同学只能帮一次传纸条，（上课就要好好听讲，帮你传一次已经够朋友了）和P1004不一样的是，两条路线不能交叉，除了小渊处和小轩处能够交叉，这么样的话，我们可以看成小渊同时发送两条纸条，且两条纸条传递的路线是不能重合的，直到两个纸条都传到小轩手里。   </p>
<p>注意到，两条路线不交叉的话，那么在相同步数的情况下，必然有一条路线的终点的行数大于另一条路线的终点的行数，这样的话，我看到很多人用了二维数组去表示在当前步数下好感度之和，但是这样会浪费一半的存储空间，很可怕，作为艰苦的朴素人，我把它降到了一维，用f[(j*(j+1))/2+i]表示代替那些大佬们的f[i][j]，注意了，这里的j是大于i的，因为我上面说了有一条路径的终点的行数大于另一条路径的终点的行数，所以我假定了第一条的路径的终点的行数要小一些。    </p>
<p>由于这一题的特殊性，我让步数的起始值为3，行数和列数必须至少加一，且两个中一个行数加二，一个列数加二。并且看到小轩处的好感度为0，所以我们一条路径到了小轩左边，一条到了小轩上面就可以结束了，所以我们步数的终止值为(m+n-1)。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_num = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n_num = <span class="number">50</span>;</span><br><span class="line">ll f[(m_num*(m_num+<span class="number">1</span>)) / <span class="number">2</span>];</span><br><span class="line">ll map[m_num+<span class="number">1</span>][m_num+n_num<span class="number">-1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">			cin &gt;&gt; map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">3</span>;l &lt;(m+n);l++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt; i;j--) &#123;</span><br><span class="line">				f[(j*(j + <span class="number">1</span>)) / <span class="number">2</span> + i] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[(j*(j + <span class="number">1</span>)) / <span class="number">2</span> + i], f[(j*(j - <span class="number">1</span>)) / <span class="number">2</span> + i - <span class="number">1</span>]), <span class="built_in">max</span>(f[(j*(j - <span class="number">1</span>)) / <span class="number">2</span> + i], f[(j*(j + <span class="number">1</span>)) / <span class="number">2</span> + i - <span class="number">1</span>])) + map[i][l - i] + map[j][l - j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[(m*(m + <span class="number">1</span>)) / <span class="number">2</span> + m - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1005（矩阵取数游戏）</title>
    <url>/2020/08/14/P1005/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n\times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$均为非负整数。游戏规则如下：   </p>
<p>1.每次取数时须从每行各取走一个元素，共 n 个。经过 m 次后取完矩阵内所有元素；<br>2.每次取走的各个元素只能是该元素所在行的行首或行尾；<br>3.每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 i 表示第 i 次取数（从 1 开始编号）；<br>4.游戏结束总得分为 m 次取数得分之和。  </p>
<p>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入文件包括 n+1 行：   </p>
<p>第一行为两个用空格隔开的整数 n 和 m。<br>第2∽n+1 行为n×m 矩阵，其中每行有 m 个用单个空格隔开的非负整数。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出文件仅包含1行，为一个整数，即输入矩阵取数后的最大得分。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题好像很难啊，我花了一个上午才做出来，首先一个重要的思想是把数组分割成小数组去遍历，递推公式是f[i,j]=max(a(i)+f[i+1,j],a(j)+f[i,j-1])，刚开始我想用递归和longlong去做，结果就报错TLE，复杂度太高了，没办法只能优化到非递归结构，选择用数组存储的形式，注意，这里我看到很多人选择用一个矩阵a去表示,a(i,j)=f(i,j),但是这样的话，f(j,i)是不存在的，就会把这个矩阵一半的空间浪费掉，这显然不符合我勤俭节约的作风，从matlab中将关于主对角线对称的矩阵降维到一维矩阵的函数得来的灵感，我选择将这个数组降到一维，这个数组被命名为d，d[(j+1)*j/2+i]表示f(i,j)，这样的话，就能物尽其用将损耗降到最低，但是测试了一下，最后4个测试点通不过，发现是long long的精度放不下，于是我定义了一个big类，用两个long long组合在一起提高精度（你觉得我会承认我用vector和数组写的高精度被报tle了吗？）   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 10000000000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">big</span> &#123;</span><span class="comment">//定义一个高精度类</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(big &amp; a, <span class="keyword">int</span> t)</span> </span>&#123;<span class="comment">//将一个int数字赋给一个高精度类</span></span><br><span class="line">	a.num1 = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(big a)</span> </span>&#123;<span class="comment">//将高精度类打印输出</span></span><br><span class="line">	<span class="keyword">if</span> (!a.num2) &#123;</span><br><span class="line">		cout &lt;&lt; a.num1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; a.num2 &lt;&lt; a.num1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">big <span class="title">add</span><span class="params">(big a, big b)</span> </span>&#123;<span class="comment">//将两个高精度类相加</span></span><br><span class="line">	big c;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = a.num1 + b.num1;</span><br><span class="line">	c.num1 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	c.num2 = a.num2 + b.num2 + t;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">big <span class="title">mult</span><span class="params">(big a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//将一个高精度类和一个不大于10的数相乘</span></span><br><span class="line">	big b;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = a.num1;</span><br><span class="line">	t *= n;</span><br><span class="line">	b.num1 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	b.num2 = (a.num2)*n + t;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">big <span class="title">max</span><span class="params">(big a, big b)</span> </span>&#123;<span class="comment">//将两个高精度进行比较</span></span><br><span class="line">	<span class="keyword">if</span> (a.num2 &gt; b.num2) &#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b.num2 &gt; a.num2) &#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a.num1 &gt; b.num1) &#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b.num1 &gt; a.num1) &#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">big f[<span class="number">81</span>];</span><br><span class="line">big ans;</span><br><span class="line"><span class="function">big <span class="title">deep</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">//对每一行进行由深到浅遍历</span></span><br><span class="line">	big d[<span class="number">3300</span>];</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; m) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = i + l;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; m) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!l) &#123;</span><br><span class="line">				d[(i*(i + <span class="number">1</span>)) / <span class="number">2</span> + i] = <span class="built_in">mult</span>(f[i], <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				d[(j*(j + <span class="number">1</span>)) / <span class="number">2</span> + i] = <span class="built_in">max</span>(<span class="built_in">add</span>(<span class="built_in">mult</span>(f[i], <span class="number">2</span>), <span class="built_in">mult</span>(d[(j*(j + <span class="number">1</span>)) / <span class="number">2</span> + i + <span class="number">1</span>], <span class="number">2</span>)), <span class="built_in">add</span>(<span class="built_in">mult</span>(f[j], <span class="number">2</span>), <span class="built_in">mult</span>(d[(j*(j - <span class="number">1</span>)) / <span class="number">2</span> + i], <span class="number">2</span>)));</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		l++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[((m<span class="number">-1</span>)*m)/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> t;</span><br><span class="line">			cin &gt;&gt; t;</span><br><span class="line">			f[j].num1 = t;</span><br><span class="line">			f[j].num2 = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">add</span>(ans, <span class="built_in">deep</span>(m));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1007（独木桥）</title>
    <url>/2020/08/14/P1007/</url>
    <content><![CDATA[<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳1个人通过。假如有2个人相向而行在桥上相遇，那么他们2个人将无妨绕过对方，只能有1个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为L，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为1，但一个士兵某一时刻来到了坐标为0或L+1的位置，他就离开了独木桥。   </p>
<p>每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。   </p>
<p>由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行：一个整数L，表示独木桥的长度。桥上的坐标为1…L</p>
<p>第二行：一个整数N，表示初始时留在桥上的士兵数目</p>
<p>第三行：有N个整数，分别表示每个士兵的初始坐标。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>只有一行，输出2个整数，分别表示部队撤离独木桥的最小时间和最大时间。2个整数由一个空格符分开。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>对于最小时间大家应该都知道，就是每个士兵刚开始的时候方向都是离自己最近的桥的端点，这样的话，就去寻找每个士兵能够到达桥端的最短时间的最大值。   </p>
<p>对于最大时间，每个士兵相遇后都会转身，但是每个士兵从宏观上看都是平等的，也是相同的，那么我们可以认为每个士兵相遇后会“灵魂交换”，即继续前进，那么我们就找每个士兵到达桥端的最大值的最大值就好了。    </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>数据范围$ N \le L \le 5000 $。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> army[<span class="number">5000</span>];</span><br><span class="line"><span class="keyword">int</span> l;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; l;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; army[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> minl = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> maxl = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="built_in">max</span>(l + <span class="number">1</span> - army[i], army[i]);</span><br><span class="line">		<span class="keyword">int</span> b = l + <span class="number">1</span> - a;</span><br><span class="line">		maxl = <span class="built_in">max</span>(maxl, a);</span><br><span class="line">		minl = <span class="built_in">max</span>(minl, b);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; minl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxl &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1008（三连击）</title>
    <url>/2020/08/14/P1008/</url>
    <content><![CDATA[<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将1,2,⋯,9共99个数分成3组，分别组成3个三位数，且使这3个三位数构成1:2:3的比例，试求出所有满足条件的3个三位数。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>木有输入</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>若干行，每行33个数字。按照每行第11个数字升序排列。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这一题我们暴力搜索就好了，对于三个数中的最小值，应该不能小于123，也不能大于329（987/3），那么就在这个区间范围内搜索可行的解就行了。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">123</span>;a &lt;= <span class="number">329</span>;a++) &#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">2</span> * a;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">3</span> * a;</span><br><span class="line">		<span class="keyword">if</span> (((a / <span class="number">100</span> + (a / <span class="number">10</span> % <span class="number">10</span>) + a % <span class="number">10</span> + b / <span class="number">100</span> + (b / <span class="number">10</span> % <span class="number">10</span>) + b % <span class="number">10</span> + c / <span class="number">100</span> + (c / <span class="number">10</span> % <span class="number">10</span>) + c % <span class="number">10</span>) == <span class="number">45</span>) &amp;&amp; ((a / <span class="number">100</span>)*(a / <span class="number">10</span> % <span class="number">10</span>)*(a % <span class="number">10</span>)*(b / <span class="number">100</span>)*(b / <span class="number">10</span> % <span class="number">10</span>)*(b % <span class="number">10</span>)*(c / <span class="number">100</span>)*(c / <span class="number">10</span> % <span class="number">10</span>)*(c % <span class="number">10</span>) == (<span class="number">1</span> * <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * <span class="number">5</span> * <span class="number">6</span> * <span class="number">7</span> * <span class="number">8</span> * <span class="number">9</span>))) &#123;</span><br><span class="line">			cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1009（阶乘之和）</title>
    <url>/2020/08/14/P1009/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>用高精度计算出S=1!+2!+3!+…+n! $(n \le 50)$<br>其中“!”表示阶乘，例如：5!=5×4×3×2×1。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一个正整数N。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个正整数S，表示计算结果。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>还是没学会高精，唉，又浪费了内存，愧疚啊   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">100000000000000000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">big</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num3 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num4 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">big <span class="title">add</span><span class="params">(big a, big b)</span> </span>&#123;<span class="comment">//将两个高精度类相加</span></span><br><span class="line">	big c;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = a.num1 + b.num1;</span><br><span class="line">	c.num1 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	t += a.num2 + b.num2;</span><br><span class="line">	c.num2 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	t += a.num3 + b.num3;</span><br><span class="line">	c.num3 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	c.num4 = t + a.num4 + b.num4;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">big <span class="title">mult</span><span class="params">(big a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	big b;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = a.num1;</span><br><span class="line">	t *= n;</span><br><span class="line">	b.num1 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	t += a.num2*n;</span><br><span class="line">	b.num2 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	t += a.num3*n;</span><br><span class="line">	b.num3 = t % num;</span><br><span class="line">	t /= num;</span><br><span class="line">	b.num4 = a.num4*n + t;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(big a)</span> </span>&#123;<span class="comment">//将高精度类打印输出</span></span><br><span class="line">	<span class="keyword">if</span> (a.num4) &#123;</span><br><span class="line">		cout &lt;&lt; a.num4 &lt;&lt; a.num3 &lt;&lt; a.num2 &lt;&lt; a.num1 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (a.num3) &#123;</span><br><span class="line">			cout &lt;&lt; a.num3 &lt;&lt; a.num2 &lt;&lt; a.num1 &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (a.num2) &#123;</span><br><span class="line">				cout &lt;&lt; a.num2 &lt;&lt; a.num1 &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				cout &lt;&lt; a.num1 &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	big ans;</span><br><span class="line">	big t;</span><br><span class="line">	t.num1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		t = <span class="built_in">mult</span>(t, i);</span><br><span class="line">		ans = <span class="built_in">add</span>(ans, t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1010（幂次方）</title>
    <url>/2020/08/14/P1010/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>任何一个正整数都可以用 2 的幂次方表示。例如 $137=2^7+2^3+2^0$。<br>同时约定方次用括号来表示，即$a^b$可表示为 a(b)。<br>由此可知，137 可表示为 2(7)+2(3)+2(0)<br>进一步：<br>$7=2^2+2+2^0$($2^1$用2表示),并且$3=2+2^0$<br>所以最后 137 可表示为2(2(2)+2+2(0))+2(2+2(0))+2(0)<br>又如$1315=2^{10}+2^8+2^5+2+1$<br>所以 1315 最后可表示为 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一行一个正整数 n。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>符合约定的 n 的 0,2表示（在表示中不能有空格）。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 100% 的数据，$1\le n\le 2\times 10^4 $。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>本来想用多叉树的，但是二叉树好像无论是处理还是遍历，都好麻烦的，而且会浪费内存，这不能忍。我用-3代表左括号，-2代表右括号，-1代表加号，这样就只用int型数据，中间我用了一个queue<int>型的数组，没错，是数组，可以轮流用，当一个数组抛出数据的时候，另一个就接数据，在抛接的过程中，就可以处理那个数据，如果那个数据大于2，就可以将它分解一次。遍历完一个队列之后，如果在这个队列抛出的过程中没有处理过任何数据，就说明没有数据需要分解了，可以转入输出环节。因为最后不知道是哪个数组存储到了我们需要输出的int数据，所以我们最后需要判断一下哪个队列不为空再输出。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> left -3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> right -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add -1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">bool</span> i = <span class="number">0</span>;</span><br><span class="line">	q[i].<span class="built_in">push</span>(n);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">bool</span> cs = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span> (!q[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = q[i].<span class="built_in">front</span>();</span><br><span class="line">			q[i].<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (t &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">				q[!i].<span class="built_in">push</span>(t);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">			   cs = <span class="literal">true</span>;</span><br><span class="line">			   <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">while</span> (t != <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">						q[!i].<span class="built_in">push</span>(add);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">int</span> mi = <span class="built_in">log</span>(t) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">					t -= <span class="built_in">pow</span>(<span class="number">2</span>, mi);</span><br><span class="line">					q[!i].<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">					<span class="keyword">if</span> (mi != <span class="number">1</span>) &#123;</span><br><span class="line">						q[!i].<span class="built_in">push</span>(left);</span><br><span class="line">						q[!i].<span class="built_in">push</span>(mi);</span><br><span class="line">						q[!i].<span class="built_in">push</span>(right);</span><br><span class="line">					&#125;</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!cs) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i = !i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!q[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!q[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = q[i].<span class="built_in">empty</span>();</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (t) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-3</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-2</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				cout &lt;&lt; t;</span><br><span class="line">			&#125;</span><br><span class="line">			q[i].<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (!q[!i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = q[!i].<span class="built_in">front</span>();</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (t) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-3</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-2</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				cout &lt;&lt; t;</span><br><span class="line">			&#125;</span><br><span class="line">			q[!i].<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1011（车站）</title>
    <url>/2020/08/14/P1011/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>火车从始发站（称为第 1 站）开出，在始发站上车的人数为 a，然后到达第 2 站，在第 2 站有人上、下车，但上、下车的人数相同，因此在第 2 站开出时（即在到达第 3 站之前）车上的人数保持为$a$ 人。从第 3 站起（包括第 3 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 $(n−1)$ 站），都满足此规律。现给出的条件是：共有$n$ 个车站，始发站上车的人数为 $b$ ，最后一站下车的人数是 $m$（全部下车）。试问 $x$ 站开出时车上的人数是多少？</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入只有一行四个整数，分别表示始发站上车人数 $a$，车站数 $n$，终点站下车人数 $m$ 和所求的站点编号 $x$。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出一行一个整数表示答案：从 $x$ 站开出时车上的人数。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于全部的测试点，保证 $1 \leq a \leq 20，1 \leq x \leq n \leq 20，1 \leq m \leq 2 \times 10^4 $。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>小瞧了斐波那契数列的能力，中间就是一个递推的关系，刚开始想简单解方程的，但是做不到，然后不要偷懒，可以自己手算一下，把大概递推关系算出来，然后就ac了。   </p>
<p>第一次提交的时候wa了，原因是我把int型数组在main()函数中定义，但是数组中的元素并不会被初始化0，我把数组在main()函数以外定义就不存在这个问题了，直接ac。  </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a_num[<span class="number">19</span>];</span><br><span class="line"><span class="keyword">int</span> b_num[<span class="number">19</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, n, m, x;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">	a_num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	a_num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	a_num[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">19</span>;i++) &#123;</span><br><span class="line">		a_num[i] = a_num[i - <span class="number">1</span>] + a_num[i - <span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">		b_num[i] = b_num[i - <span class="number">1</span>] + b_num[i - <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> b = (m - a_num[n - <span class="number">2</span>] * a) / b_num[n - <span class="number">2</span>];</span><br><span class="line">	cout &lt;&lt; (a_num[x - <span class="number">1</span>] * a + b_num[x - <span class="number">1</span>] * b) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1013（进制位）</title>
    <url>/2020/08/14/P1013/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>著名科学家卢斯为了检查学生对进位制的理解，他给出了如下的一张加法表，表中的字母代表数字。 例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+    L    K    V    E</span><br><span class="line">L    L    K    V    E</span><br><span class="line">K    K    V    E    KL</span><br><span class="line">V    V    E    KL   KK</span><br><span class="line">E    E    KL   KK   KV</span><br></pre></td></tr></table></figure>
<p>其含义为：<br>L+L=L，L+K=K，L+V=V，L+E=E</p>
<p>K+L=K，K+K=V，K+V=E，K+E=KL</p>
<p>…… E+E=KV<br>根据这些规则可推导出：L=0，K=1，V=2，E=3<br>同时可以确定该表表示的是4进制加法</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>n $(n\le 9)$表示行数。</p>
<p>以下n行，每行包括n个字符串，每个字串间用空格隔开。（字串仅有一个为‘+’号，其它都由大写字母组成）</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>1.各个字母表示什么数，格式如：L=0，K=1，……按给出的字母顺序。</p>
<p>2.加法运算是几进制的。</p>
<p>3.若不可能组成加法表，则应输出“ERROR!”</p>
<h1 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h1><p>洛谷里大神好多啊，这一次我会整理一下各种思路，最后再亮出代码。</p>
<h2 id="0级解法"><a href="#0级解法" class="headerlink" title="0级解法"></a>0级解法</h2><p>不知道有没有人和我一样，一开始看到这题的时候，想用解方程的方法做，先在(n-1)*(n-1)个数中挑选n个数出来解方程，之后把结果代入表格中看是否能对上，但是这样复杂度蛮高的，而且acm不支持matlab，用c++去解方程想想就头疼，而且解方程中，遇到有进位的数，又不知道进制，这就很麻烦了。</p>
<h2 id="1级解法"><a href="#1级解法" class="headerlink" title="1级解法"></a>1级解法</h2><p>在这个表中，必定存在有进位的数，且进制必为n-1，所要求的数必定是0，1，2，3，…,n-2这些数且只出现一次，为什么呢？请听我娓娓道来。   </p>
<p>首先是为什么一定有进位呢？假设所有字符中对应的值最大是X，那么表中必有一项是X+X的，但是这样的话就没办法用其它字符表示，只可能是有进位存在。  </p>
<p>然后，如果有进位，那么这些数中一定存在1，1+1=2，就一定有2，1+2=3，就一定有3，…1+n-3=n-2,同时因为进位，字符里必定有表示0的字符。注意到，这里0,1,2,3,…n-2一共n-1个数了，刚好对应了n-1个字符，这也说明了进制至少是n-1，同时，注意到，1+(n-2)=n-1,这是一个不存在于上面那串数字中的数，只可能是用有进位的数表示的，所以进制至多是n-1。然后就说明了进制是n-1。(有点像高数求极限里夹逼定理)</p>
<h2 id="2级解法"><a href="#2级解法" class="headerlink" title="2级解法"></a>2级解法</h2><p>这是一位大佬提出的解法，我真想把膝盖献给他(她）,这是对1级解法的完美升华啊!   </p>
<p>注意表中单字符的数据，x=0+x=1+(x-1)=2+(x-2)=…=(x-2)+2=(x-1)+1=x+0,注意到，如果一个字符在表中单字符中出现了x次，那么它就是x-1，简单粗暴。</p>
<h2 id="3级解法"><a href="#3级解法" class="headerlink" title="3级解法"></a>3级解法</h2><p>希望我能遇到，或者有人知道的话一定要不吝赐教。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">9</span>];</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">			cin &gt;&gt; s[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">		mymap.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(s[<span class="number">0</span>][i],<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i][j].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">				mymap[s[i][j]] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>;ii &lt; s[i][j].<span class="built_in">size</span>();ii++) &#123;</span><br><span class="line">				t *= (n - <span class="number">1</span>);</span><br><span class="line">				t += mymap[s[i][j].<span class="built_in">substr</span>(ii, <span class="number">1</span>)];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> tt = mymap[s[i][<span class="number">0</span>]] + mymap[s[<span class="number">0</span>][j]];</span><br><span class="line">			<span class="keyword">if</span> (t != tt) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;ERROR!&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cout &lt;&lt; s[<span class="number">0</span>][i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; mymap[s[<span class="number">0</span>][i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1012（拼数）</title>
    <url>/2020/08/14/P1012/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设有 n 个正整数 $a_1 \dots a_n$，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有一个整数，表示数字个数 n。</p>
<p>第二行有 n 个整数，表示给出的 n 个整数 $a_i$ 。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个正整数，表示最大的整数</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于全部的测试点，保证 $1 \leq n \leq 20，1 \leq a_i \leq 10^9 $。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>对于这一题，我刚开始还是想老老实实用int或long做的，但是看了一位大佬的做法，用string做，就很自然的解决了数字连接的问题，所以果断string。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; (n - i<span class="number">-1</span>);j++) &#123;</span><br><span class="line">			string s1 = s[j] + s[j + <span class="number">1</span>];</span><br><span class="line">			string s2 = s[j + <span class="number">1</span>] + s[j];</span><br><span class="line">			<span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">				string t = s[j];</span><br><span class="line">				s[j] = s[j+<span class="number">1</span>];</span><br><span class="line">				s[j+<span class="number">1</span>] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cout &lt;&lt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1014（Cantor表）</title>
    <url>/2020/08/14/P1014/</url>
    <content><![CDATA[<p>这题是个入门题，只要看清楚题，都不会有问题的，什么？你问我为啥要写这篇博客？读书人水博客能叫水博客吗？说罢，气氛便欢乐了起来。</p>
<span id="more"></span>
<p>Talking is cheap,show you my code.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(<span class="number">2</span> * N + <span class="number">0.25</span>) - <span class="number">0.5</span>);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = N - (n*(n - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; (n + <span class="number">1</span> - t) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1015（回文数）</title>
    <url>/2020/08/14/P1015/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。<br>例如：给定一个十进制数 56，将 56 加 65（即把 5656 从右向左读），得到 121 是一个回文数。  </p>
<p>又如：对于十进制数 87：<br>STEP1：87+78=165<br>STEP2：165+561=726<br>STEP3：726+627=1353<br>STEP4：1353+3531=4884  </p>
<p>在这里的一步是指进行了一次 N 进制的加法，上例最少用了 4 步得到回文数 4884。<br>写一个程序，给定一个 N（$2\le N\le 10$ 或 $N=16$）进制数 M（100 位之内），求最少经过几步可以得到回文数。如果在 30 步以内（包含 30 步）不可能得到回文数，则输出 Impossible!。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>两行，分别是 N，M。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>如果能在 30 步以内得到回文数，输出格式形如 STEP=ans，其中 ans 为最少得到回文数的步数。<br>否则输出 Impossible!。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>看到题目中说的有100位数据，再来个30次进位，多少个long long才放得下呀，所以我立马选择建立一个130位的数组，去存储，其实也不是很难。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">130</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	string M;</span><br><span class="line">	cin &gt;&gt; M;</span><br><span class="line">	<span class="keyword">int</span> size = M.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">		string str = M.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">char</span> cc = str[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> ((cc &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (cc &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">			num[i] = cc - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			num[i] = cc - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = size - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(num[i], num[j]);</span><br><span class="line">		i++;</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>;ii &lt; <span class="number">30</span>;ii++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end = size - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (end &gt; begin) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num[begin] != num[end]) &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			begin++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;STEP=&quot;</span> &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		step++;</span><br><span class="line">		<span class="keyword">int</span> mun[<span class="number">130</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> ij = <span class="number">0</span>;ij &lt; size;ij++) &#123;</span><br><span class="line">			mun[ij] = num[size - <span class="number">1</span> - ij];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; size;k++) &#123;</span><br><span class="line">			t += num[k] + mun[k];</span><br><span class="line">			num[k] = t % N;</span><br><span class="line">			t /= N;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t) &#123;</span><br><span class="line">			num[size] = t;</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Impossible!&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1016（旅行家的预算）</title>
    <url>/2020/08/14/P1016/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格PP和沿途油站数N（N可以为零），油站ii离出发点的距离Di、每升汽油价格Pi（i=1,2,…,N）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行，D1，C，D2，P，N<br>接下来有N行。<br>第i+1行，两个数字，油站i离出发点的距离Di和每升汽油价格Pi。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>所需最小费用，计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。</p>
<h1 id="提示-说明"><a href="#提示-说明" class="headerlink" title="提示/说明"></a>提示/说明</h1><p>$N \le 6$,其余数字$\le 500$</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这一题，有点麻烦，本来想用滚动数组的，就像P1004那样，但是有个问题，里面涉及到汽车油量的问题，如果前面的油没用完，那么会影响到后面的花费问题，也就是说，它们并不是一个相互独立的问题，而是相互关联的。   </p>
<p>但是我们可以结合实际去考虑这一题，现实生活中，我们如果进行长途旅行，如果两个加油站之间的距离，就算我们用完汽车油箱里所有油都到不了，那就只能输出”No Solution”了，表示我们无能为力啊，实在到不了。然后就算我们到得了，也要考虑花费问题，毕竟省下来的钱我们可以用来买好多好吃的。这里我们可以知道C*D2是我们的能到达范围。如果在能到达的范围内有一个加油站比现在所处的加油站油价便宜，那么只要刚刚好到那个加油站就好了，因为后续的路我们可以用更加便宜的油行驶下去，如果不巧，我们能到达的范围油价都比我们现在所处的加油站的油价贵，那么加满，并且选择那些贵的加油站中的最便宜的加油站作为下一次加油点。一次一次行驶下去，最后到了终点城市，这时候，油箱里应该没有剩下油了，才能说明我们花的钱用的刚刚好。    </p>
<p>因为我是自学这些题的，所以不懂实际怎么判断正确性，但是注意，这道题里有个测试点的答案在0.01位置上是0，我第一次输出没有输出这个0，结果就WA了，还是太年轻了。    </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> d1;</span><br><span class="line"><span class="keyword">double</span> c;</span><br><span class="line"><span class="keyword">double</span> d2;</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> pi[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">double</span> di[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">double</span> cost;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; d1 &gt;&gt; c &gt;&gt; d2 &gt;&gt; p &gt;&gt; n;</span><br><span class="line">	<span class="keyword">double</span> h = <span class="number">0</span>;<span class="comment">//汽车油量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; di[i] &gt;&gt; pi[i];</span><br><span class="line">	&#125;</span><br><span class="line">	pi[<span class="number">0</span>] = p;</span><br><span class="line">	di[n + <span class="number">1</span>] = d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (n+<span class="number">1</span>) ;i &gt; <span class="number">0</span>;i--) &#123;</span><br><span class="line">		di[i] -= di[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (di[i] &gt; (c * d2)) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//汽车到的位置</span></span><br><span class="line">	<span class="keyword">while</span> (flag != (n + <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = flag + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">double</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> minp = <span class="number">500</span>;</span><br><span class="line">		<span class="keyword">int</span> pmin = i;</span><br><span class="line">		<span class="keyword">while</span> ((len+di[i]) &lt;= (c*d2)) &#123;</span><br><span class="line">			len += di[i];</span><br><span class="line">			<span class="keyword">if</span> (pi[i] &lt; minp) &#123;</span><br><span class="line">				minp = pi[i];</span><br><span class="line">				pmin = i;</span><br><span class="line">				<span class="keyword">if</span> (pi[i] &lt;= pi[flag]) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (minp &lt;= pi[flag]) &#123;</span><br><span class="line">			cost += ((len / d2) - h)*pi[flag];</span><br><span class="line">			h = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cost += (c - h)*pi[flag];</span><br><span class="line">			h = c - len / d2;</span><br><span class="line">		&#125;</span><br><span class="line">		flag = pmin;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; fixed &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1017（进制转换）</title>
    <url>/2020/08/14/P1017/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们可以用这样的方式来表示一个十进制数: 将每个阿拉伯数字乘以一个以该数字所处位置为指数,以 10 为底数的幂之和的形式。例如 123可表示为 $1 \times {10}^2+2 \times {10}^1+3\times {10}^0$这样的形式。  </p>
<p>与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数,以 2 为底数的幂之和的形式。     </p>
<p>一般说来，任何一个正整数 R 或一个负整数 −R 都可以被选来作为一个数制系统的基数。如果是以 R 或 −R 为基数,则需要用到的数码为 0,1,….R-1。    </p>
<p>例如当 R=7 时,所需用到的数码是 0,1,2,3,4,5,6，这与其是 R 或 −R 无关。如果作为基数的数绝对值超过 10,则为了表示这些数码，通常使用英文字母来表示那些大于 9 的数码。例如对 16 进制数来说,用 A 表示 10,用 B 表示 11，用 C 表示 12，以此类推。   </p>
<p>在负进制数中是用 −R 作为基数，例如 −15（十进制）相当于 110001 （−2进制），并且它可以被表示为 2 的幂级数的和数：<br>$110001=1\times{(-2)}^5+1\times{(-2)}^4+0\times{(-2)}^3+0\times{(-2)}^2+0\times{(-2)}^1+1\times{(-2)}^0$  </p>
<p>设计一个程序,读入一个十进制数和一个负进制数的基数, 并将此十进制数转换为此负进制下的数。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入的每行有两个输入数据。<br>第一个是十进制数 n。 第二个是负进制数的基数 −R。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出此负进制数及其基数，若此基数超过 10，则参照 16 进制的方式处理。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 $ 100% $ 的数据，$-20 \le R \le -2，|n| \le 37336 $。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题可能有点吓人的就是负数除法，这个其实也没啥，如果熟正数的，负数也简单，但是注意一点就是除出来之后可能是一个负数，当然，这个负数的绝对值一定比除数的绝对值小，这和普通除法还是一样的，那么可以用余数减一个除数，相应地，商要加一，接着用商除以除数，直到商为0。    </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> R;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; R;</span><br><span class="line">	m = n;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> t = n % R;</span><br><span class="line">		n /= R;</span><br><span class="line">		<span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			t -= R;</span><br><span class="line">			n += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s.<span class="built_in">push</span>(t);</span><br><span class="line">	&#125; <span class="keyword">while</span> (n != <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; m &lt;&lt; <span class="string">&quot;=&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = s.<span class="built_in">top</span>();</span><br><span class="line">		<span class="keyword">if</span> ((<span class="number">0</span> &lt;= i) &amp;&amp; (i &lt;= <span class="number">9</span>)) &#123;</span><br><span class="line">			cout &lt;&lt; i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> c = (<span class="string">&#x27;A&#x27;</span> + i - <span class="number">10</span>);</span><br><span class="line">			cout &lt;&lt; c;</span><br><span class="line">		&#125;</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;(base&quot;</span> &lt;&lt; R &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1019（单词接龙）</title>
    <url>/2020/08/14/P1019/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at 和 atide 间不能相连。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入的第一行为一个单独的整数n (n≤20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>只需输出以此字母开头的最长的“龙”的长度</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这一题要看清楚题目哦，每个单词可能出现2次，然后还有个隐藏条件没说的，就是龙头不一定只有一个啊，比如龙头的字母是a，但是有单词able和apple，那么这两个单词都能作为龙头。    </p>
<p>深度遍历尽量别用递归，虽然这一题的单词量小，但是我学ac的初衷是提高自己的解决问题的思路水平，万一以后需要处理大数据量的相同题目，过度依赖递归就显然违背了我的初衷，所以果断堆栈寄存器，别说，用堆栈的实现方法运行时间也足够优秀。可是有个问题，这一题的dfs和普通dfs有点不一样的就是每个点允许经过两次，那么我定义了一个begin，初始值为-1，每一次取数时从begin开始取数，如果那个单词可取，即使用次数少于2，且与上一次当前遍历的堆栈寄存器的栈顶单词有交叉部分，那么就将其入栈，且更新begin为-1，如果取不到数，就跟新begin为堆栈的栈顶单词的序号，堆栈做一次退栈处理。直到栈为空。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string word[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> jc[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> use[<span class="number">30</span>];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; sw;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lianjie</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	string a = word[i];</span><br><span class="line">	string b = word[j];</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; size;i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[a.<span class="built_in">size</span>() - i + j] != b[j]) &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yuchuli</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">			jc[i][j] = <span class="built_in">lianjie</span>(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">	use[i]++;</span><br><span class="line">	mystack.<span class="built_in">push</span>(i);</span><br><span class="line">	len += word[i].<span class="built_in">size</span>();</span><br><span class="line">	l = len;</span><br><span class="line">	<span class="keyword">int</span> begin = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = begin + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((use[j]&lt;<span class="number">2</span>) &amp;&amp; (jc[mystack.<span class="built_in">top</span>()][j])) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">			len = <span class="built_in">max</span>(len, l);</span><br><span class="line">			begin = mystack.<span class="built_in">top</span>();</span><br><span class="line">			use[begin]--;</span><br><span class="line">			l -= word[begin].<span class="built_in">size</span>();</span><br><span class="line">			mystack.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (mystack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			l += jc[mystack.<span class="built_in">top</span>()][begin];</span><br><span class="line">			<span class="keyword">if</span> ((mystack.<span class="built_in">top</span>() == i)&amp;&amp;(mystack.<span class="built_in">size</span>()==<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			begin = <span class="number">-1</span>;</span><br><span class="line">			use[j]++;</span><br><span class="line">			l -= jc[mystack.<span class="built_in">top</span>()][j];</span><br><span class="line">			mystack.<span class="built_in">push</span>(j);</span><br><span class="line">			l += word[j].<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	use[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; word[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">	<span class="built_in">yuchuli</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (word[i][<span class="number">0</span>] == c) &#123;</span><br><span class="line">			sw.<span class="built_in">push</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!sw.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		len = <span class="built_in">max</span>(len, <span class="built_in">dfs</span>(sw.<span class="built_in">top</span>()));</span><br><span class="line">		sw.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1018（乘积最大）</title>
    <url>/2020/08/14/P1018/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>今年是国际数学联盟确定的“2000――世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰9090周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZXZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：  </p>
<p>设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。   </p>
<p>同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：<br>有一个数字串：312， 当N=3,K=1时会有以下两种分法：<br>1、3×12=36<br>2、31×2=62<br>这时，符合题目要求的结果是: 31×2=62  </p>
<p>现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>程序的输入共有两行：<br>第一行共有2个自然数N,K（6≤N≤40,1≤K≤6）<br>第二行是一个长度为N的数字串。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>第一次用string做高精度就好香啊，熟悉高精度的朋友可以不用颠倒string，更加直观有没有。string的substr()和size()函数结合在一起感觉就像是为这题量身打造，但是有个问题，运行速度比较慢。    </p>
<p>ans[i][j]表示前i个数中插入j个乘号后的最大值，我们最后输出ans[n][k]就好了。    </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string n;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">string ans[<span class="number">41</span>][<span class="number">7</span>];</span><br><span class="line"><span class="function">string <span class="title">mult</span><span class="params">(string a, string b)</span> </span>&#123;<span class="comment">//两个高精度的乘法</span></span><br><span class="line">	string c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> as = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> bs = b.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> ((!as) || (!bs)) &#123;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> size = as + bs;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">		c += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (as<span class="number">-1</span>);i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (bs<span class="number">-1</span>);j &gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">			<span class="keyword">int</span> k = i + j + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">char</span> aa = a[i];</span><br><span class="line">			<span class="keyword">char</span> bb = b[j];</span><br><span class="line">			<span class="keyword">int</span> ai = aa - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">int</span> bi = bb - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">int</span> ab = ai * bi;</span><br><span class="line">			<span class="keyword">while</span> (ab != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">char</span> cc = c[k];</span><br><span class="line">				<span class="keyword">int</span> ci = cc - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				ci += ab;</span><br><span class="line">				ab = ci / <span class="number">10</span>;</span><br><span class="line">				ci = ci % <span class="number">10</span>;</span><br><span class="line">				<span class="keyword">char</span> sc = <span class="string">&#x27;0&#x27;</span> + ci;</span><br><span class="line">				c[k] = sc;</span><br><span class="line">				k--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((c.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &amp;&amp; (c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">		c.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">max</span><span class="params">(string a, string b)</span> </span>&#123;<span class="comment">//求最大的值</span></span><br><span class="line">	<span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b.<span class="built_in">size</span>() &gt; a.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		ans[i][<span class="number">0</span>] = s.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>;m &lt; j;m++) &#123;</span><br><span class="line">				ans[j][i] = <span class="built_in">max</span>(ans[j][i], <span class="built_in">mult</span>(ans[m][i - <span class="number">1</span>], s.<span class="built_in">substr</span>(m , j - m)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans[n][k];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1020（导弹拦截）</title>
    <url>/2020/08/14/P1020/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>输入导弹依次飞来的高度（雷达给出的高度数据是≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>1行，若干个整数（个数≤100000）</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>做了这一题我才发现我好笨啊，不得不说我的dp功底不够。   </p>
<p>#define int num[100000] 数组存储导弹高度序列。</p>
<h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><p>第一问就是问一个不上升的最长序列，这个大家都懂，那么怎么求呢，首先构造一个int d1[100000]，这个数组里有效数字的长度就是我们要求的不上升序列的长度，注意，我们只需要求长度，但是序列里各个元素是些什么我们不需要知道，于是就有了这一个非常高明的dp方法（我也是看的大佬代码)，假设d1末尾的元素是d1[len1-1]，新遍历的元素是num[i]，如果num[i]小于等于d1[len1-1]，那么num[i]就接着d1[len1-1]就好了，因为这是一个不上升序列嘛；但是若num[i]大于d1[len1-1]，那么就去d1[0]~d1[len1-1]中找到第一个小于等于num[i]的元素并用num[i]替换掉他。   </p>
<p>为什么可以替换呢？假设找到的那个元素就是d1[len1-1]，那么替换掉后，num数组后面出现的元素就更容易尾接上这个序列，如果这个元素在d1的中间某处，那么替换掉后，可以理解成对树的的dp过程中的分叉，作用也是为了让之后的num序列中的数跟容易插入，一直影响到d1的尾端，理解起来很复杂，就可以按照dp的分叉之后覆写理解。</p>
<h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><p>第二问先说结果，是构造一个最长上升序列，这个序列的长度就是我们所要求的，我们假设为p，构造的方法和第一问类似。为什么这样呢，首先用第一问的方法可以把num序列分成1，2，3，…，s个单调不上升序列，注意，按照第一问的方法，构造过程中，1序列尽可能长，之后再去构造2序列，2序列也尽可能的长，之后再去构造3序列，一直这样下去。构造中有个小细节我们要注意，如果一个序列中某个位置中填a或b都可以，但是无论填哪个，都对这个序列的长度没有影响，我们就填最小的那个，这样的话对于s的值没有任何影响，大家可以自己去证一下，这样一个规定有什么用呢，请往下看。    </p>
<p>从1，2，3，…，s序列中各取最后一个元素设为t1,t2,t3,…,ts，那么一定有ts&gt;…&gt;t3&gt;t2&gt;t1,假设t1&gt;=t2：如果t2在num数组中出现在t1前面，那么序列1中末尾的元素应该是t2而不是t1，不然就违反了我上面的规定；如果t2在num数组出现在t1后面，那么序列1中t1后面应该接着t2。无论是哪个，都有事实不符，所以t1,t2,t3,…,ts构成了一个上升序列，所以p&gt;=s，同时最长序列中任意两个元素必定不能来自同一个不上升序列，所以p&lt;=s。由夹逼的思想知道，p=s。   </p>
<p>上面是一些数学推导，但是实际编程的时候不用实现，只用仿照第一问的方法构造出单调上升序列就好了。我看到一些大佬们说第二问是Dilworth定理，可惜我愚钝，没有理解。    </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> d1[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> d2[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; num[n]) &#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">	d1[<span class="number">0</span>] = num[<span class="number">0</span>];</span><br><span class="line">	d2[<span class="number">0</span>] = num[<span class="number">0</span>];</span><br><span class="line">	len1++;</span><br><span class="line">	len2++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (d1[len1 - <span class="number">1</span>] &gt;= num[i]) &#123;</span><br><span class="line">			d1[len1] = num[i];</span><br><span class="line">			len1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> p = <span class="built_in">upper_bound</span>(d1, d1 + len1 - <span class="number">1</span>, num[i], greater&lt;<span class="keyword">int</span>&gt;()) - d1;</span><br><span class="line">			d1[p] = num[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (d2[len2 - <span class="number">1</span>] &lt; num[i]) &#123;</span><br><span class="line">			d2[len2] = num[i];</span><br><span class="line">			len2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> p = <span class="built_in">lower_bound</span>(d2, d2 + len2 - <span class="number">1</span>, num[i]) - d2;</span><br><span class="line">			d2[p] = num[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; len1 &lt;&lt; endl &lt;&lt; len2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1021（邮票面值设计）</title>
    <url>/2020/08/14/P1021/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个信封，最多只允许粘贴N张邮票，计算在给定K（N+K≤15）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值MAX，使在1至MAX之间的每一个邮资值都能得到。    </p>
<p>例如，N=3，K=2，如果面值分别为1分、4分，则在1分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）；如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当N=3，K=2时，7分就是可以得到的连续的邮资最大值，所以MAX=7，面值分别为1分、3分。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>2个整数，代表N，K。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>2行。第一行若干个数字，表示选择的面值，从小到大排序。<br>第二行，输出“MAX=S”，S表示最大的面值。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>首先连续的数字里必定有1，所以邮票面值里必定有1，他要连续，下一张邮票的面值必定是1+1到1<em>n+1里面选，同样地类推，如果我某一步取了x，那么下一步就必定从x+1到x</em>n+1中选，那么不难看出，这里是一个深度搜索的过程，也就是我们说的dfs。  </p>
<p>在dfs过程中，如果我们搜索到底部了，也就是说搜索了k层，那么这时候就开始把这条搜索路上的所有节点，也就是可能面值拿去动态规划，看看它们组成的连续数怎么样，如果它们能组成的连续数比之前的都大，那么就暂时选择它，但是还要观察，如果后面出现的连续数更加大，那么就把它替换掉。   </p>
<p>其实深度搜索的方法大家应该都知道，只是递归不递归的区别而已，那么动态规划呢？我们可以看看，我们建立一个数组，int f[50000],f[i]就表示组成一个总面值为i最少需要几张邮票。在规划过程中，如果已经有了面值为i的邮票，那么f[i]就为1，如果没有，那么就算总面值为i的邮票必定能分成两部分邮票，那么向下求两部分邮票分别所需的最小有票数。比如我有1和3两种面值的邮票，允许最多贴三张邮票。因为已经有面值为1的邮票了，所以f[1]=1，但是没有面值为2的邮票，所以f[2]=f[1]+f[1]=2,同理，<br>f[3]=1;<br>f[4]=min(f[1]+f[3],f[2]+f[2])=min(2,4)=2;<br>f[5]=min(f[1]+f[4],f[2]+f[3])=min(3,3)=3;<br>f[6]=min(f[1]+f[5],f[2]+f[4],f[3]+f[3])=min(4,4,2)=2;<br>f[7]=min(f[1]+f[6],f[2]+f[5],f[3]+f[4])=min(3,5,3)=3;<br>f[8]=min(f[1]+f[7],f[2]+f[6],f[3]+f[5],f[4]+f[4])=min(4,4,4,4)=4;<br>注意看，这里f[8]已经大于k也就是我假设的3了，那么8是不合适的，所以面值1和3的邮票在k=3的情况下max为7。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n张邮票</span></span><br><span class="line"><span class="keyword">int</span> k;<span class="comment">//k种邮票</span></span><br><span class="line"><span class="keyword">int</span> stack[<span class="number">15</span>];<span class="comment">//dfs需要</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">15</span>];<span class="comment">//输出答案</span></span><br><span class="line"><span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f[<span class="number">50000</span>];</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (begin&lt;<span class="number">50000</span>) &#123;</span><br><span class="line">		f[begin] = inf;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stack[i] == begin) &#123;</span><br><span class="line">				f[begin] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (f[begin] != <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= (begin / <span class="number">2</span>);j++) &#123;</span><br><span class="line">				f[begin] = <span class="built_in">min</span>(f[begin], f[j] + f[begin - j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (f[begin] &gt; n) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	begin--;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt; maxx) &#123;</span><br><span class="line">		maxx = begin;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">			ans[i] = stack[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	stack[++num] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (num) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num &lt; k) &#123;</span><br><span class="line">			stack[num + <span class="number">1</span>] = stack[num] + <span class="number">1</span>;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">dp</span>();</span><br><span class="line">			<span class="keyword">int</span> flag = stack[num];</span><br><span class="line">			stack[num] = <span class="number">0</span>;</span><br><span class="line">			num--;</span><br><span class="line">			<span class="keyword">while</span> (num &amp;&amp; (flag == (stack[num] * n + <span class="number">1</span>))) &#123;</span><br><span class="line">				flag = stack[num];</span><br><span class="line">				stack[num] = <span class="number">0</span>;</span><br><span class="line">				num--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (num) &#123;</span><br><span class="line">				stack[num + <span class="number">1</span>] = flag + <span class="number">1</span>;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;MAX=&quot;</span> &lt;&lt; maxx &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1022（计算器的改良）</title>
    <url>/2020/08/14/P1022/</url>
    <content><![CDATA[<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>NCL是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手ZL先生。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>为了很好的完成这个任务，ZL先生首先研究了一些一元一次方程的实例：<br>4+3x=8<br>6a-5+1=2-2a<br>-5+12y=0   </p>
<p>ZL先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及+、-、=这三个数学符号（当然，符号“-”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。   </p>
<p>你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一个一元一次方程。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>解方程的结果(精确至小数点后三位)。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题是在我写P1021的过程中顺手做的，但还是WA了一次，有两个坑，一个坑是编程中0*（-1）=-0，但是输出结果必须为0，还有一个就是有的未知数前面是没有系数的。注意这两点就可以轻松过。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">double</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> ysf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> name;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">		<span class="keyword">char</span> c = str[i];</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">			ysf = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				ysf = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (c == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					ysf = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">						name = c;</span><br><span class="line">						<span class="keyword">if</span> ((i == <span class="number">0</span>) || (str[i - <span class="number">1</span>] &lt; <span class="string">&#x27;0&#x27;</span>) || (str[i - <span class="number">1</span>] &gt; <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">							k++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">							t *= <span class="number">10</span>;</span><br><span class="line">							<span class="keyword">int</span> it = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">							t += it;</span><br><span class="line">							<span class="keyword">if</span> (((i + <span class="number">1</span>) == size) || (str[i + <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span>) || (str[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) || (str[i + <span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">								<span class="keyword">if</span> (ysf == flag) &#123;</span><br><span class="line">									b += t;</span><br><span class="line">									t = <span class="number">0</span>;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">else</span> &#123;</span><br><span class="line">									b -= t;</span><br><span class="line">									t = <span class="number">0</span>;</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">if</span> (str[i + <span class="number">1</span>] &gt;= <span class="string">&#x27;a&#x27;</span>&amp;&amp;str[i + <span class="number">1</span>] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">									<span class="keyword">if</span> (ysf == flag) &#123;</span><br><span class="line">										k += t;</span><br><span class="line">										t = <span class="number">0</span>;</span><br><span class="line">									&#125;</span><br><span class="line">									<span class="keyword">else</span> &#123;</span><br><span class="line">										k -= t;</span><br><span class="line">										t = <span class="number">0</span>;</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> ans = b / k;</span><br><span class="line">	<span class="keyword">if</span> (ans) &#123;</span><br><span class="line">		ans *= <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1023（税收与补贴问题）</title>
    <url>/2020/08/14/P1023/</url>
    <content><![CDATA[<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）   </p>
<p>对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。   </p>
<p>总利润=单位商品利润 $\times $ 销量   </p>
<p>单位商品利润=单位商品价格 - 单位商品成本 （- 税金 or + 补贴）</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行-1−1，-1−1表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。</p>
<h1 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h1><p>输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。<br>如在政府预期价上不能得到最大总利润，则输出“NO SOLUTION”。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>所有数字均小于100000</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>好麻烦啊这题，相连两个数之间还可能有几个数，需要自己手动补，我看到一些大佬们在解不等式方程组的方式，然而弱鸡的我好头大，于是我选择了暴力搜索的方法，但是其实暴力搜索是有一个坑的，就是无法判断是否有解，那么我们只从实际出发，认为政府补贴或收税的值不会大于商品的价值，这样，暴力搜索便有了边界。还有最后一个测试点我用float老是出错，害的我用matlab验算（matlab真香），改用double，迅速ac。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> yuce;</span><br><span class="line"><span class="keyword">double</span> dt[<span class="number">100010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> down;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; yuce;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((dt[i<span class="number">-1</span>][<span class="number">0</span>]!=<span class="number">-1</span>)||(dt[i<span class="number">-1</span>][<span class="number">1</span>]!=<span class="number">-1</span>)) &#123;</span><br><span class="line">		cin &gt;&gt; dt[i][<span class="number">0</span>] &gt;&gt; dt[i][<span class="number">1</span>];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	i -= <span class="number">2</span>;</span><br><span class="line">	cin &gt;&gt; down;</span><br><span class="line">	<span class="keyword">double</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (k&lt;=<span class="number">100000</span>) &#123;</span><br><span class="line">		<span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> m = dt[j][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">double</span> s = dt[j][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">double</span> xh = (dt[j + <span class="number">1</span>][<span class="number">1</span>] - dt[j][<span class="number">1</span>]) / (dt[j + <span class="number">1</span>][<span class="number">0</span>] - dt[j][<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">while</span> (m &lt; dt[j + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">				<span class="keyword">double</span> zlr = (m - dt[<span class="number">1</span>][<span class="number">0</span>] + k)*s;</span><br><span class="line">				<span class="keyword">if</span> (zlr &gt;= max) &#123;</span><br><span class="line">					max = zlr;</span><br><span class="line">					temp = m;</span><br><span class="line">				&#125;</span><br><span class="line">				m++;</span><br><span class="line">				s += xh;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">double</span> m = dt[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">double</span> s = dt[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (s&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">double</span> zlr = (m - dt[<span class="number">1</span>][<span class="number">0</span>] + k)*s;</span><br><span class="line">			<span class="keyword">if</span> (zlr &gt;= max) &#123;</span><br><span class="line">				max = zlr;</span><br><span class="line">				temp = m;</span><br><span class="line">			&#125;</span><br><span class="line">			m++;</span><br><span class="line">			s -= down;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp == yuce) &#123;</span><br><span class="line">			cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		max = <span class="number">0</span>;</span><br><span class="line">		temp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> m = dt[j][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">double</span> s = dt[j][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">double</span> xh = (dt[j + <span class="number">1</span>][<span class="number">1</span>] - dt[j][<span class="number">1</span>]) / (dt[j + <span class="number">1</span>][<span class="number">0</span>] - dt[j][<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">while</span> (m &lt; dt[j + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">				<span class="keyword">double</span> zlr = (m - dt[<span class="number">1</span>][<span class="number">0</span>] - k)*s;</span><br><span class="line">				<span class="keyword">if</span> (zlr &gt;= max) &#123;</span><br><span class="line">					max = zlr;</span><br><span class="line">					temp = m;</span><br><span class="line">				&#125;</span><br><span class="line">				m++;</span><br><span class="line">				s += xh;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		m = dt[i][<span class="number">0</span>];</span><br><span class="line">		s = dt[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">double</span> zlr = (m - dt[<span class="number">1</span>][<span class="number">0</span>] - k)*s;</span><br><span class="line">			<span class="keyword">if</span> (zlr &gt;= max) &#123;</span><br><span class="line">				max = zlr;</span><br><span class="line">				temp = m;</span><br><span class="line">			&#125;</span><br><span class="line">			m++;</span><br><span class="line">			s -= down;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp == yuce) &#123;</span><br><span class="line">			cout &lt;&lt; (<span class="number">-1</span>)*k &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;NO SOLUTION&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1025（数的划分）</title>
    <url>/2020/08/14/P1025/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将整数n分成k份，且每份不能为空，任意两个方案不相同(不考虑顺序)。<br>例如：n=7，k=3，下面三种分法被认为是相同的。<br>1,1,5;<br>1,5,1;<br>5,1,1.<br>问有多少种不同的分法</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>n,k $(6\le n\le 200，2\le k\le 6)$</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>1个整数，即不同的分法。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题我是没有啥骚骚的办法，只能老老实实的dfs了，dfs过程中，差点就被递归诱惑了，不能忍，果断数组当栈用。   </p>
<p>要注意一个点，就是题目中重复的不算，我们可以考虑下，怎么样算重复呢，把两组数据分别从小到大排序一遍，再一一比较，如果都一样，那么就说这两组数据重复了，但是我们如果在写代码过程中真的去排序那就完蛋了，肯定浪费时间，那么我们可以在取数的时候规定后一次取的数不小于前一次取得数，我们令$a_i$为第i次取的数，那么显然有$a_1\le a_2\le …\le a_k$，且必定有$a_1+a_2+…+a_k=n$ ，那这个dfs就有意思了。为了满足每次取数的时候都不小于前一次取数，第i次取数的范围是$a_{i-1}$~$(n-\int_{t=1}^{i-1}a_t)/(k+1-i)$，如果取太大了，后面的数就取不到不小于前面的数了。就这么往下搜索下去，直到搜索到(k-1)层，为什么不到k层呢，注意看，$a_1+a_2+…+a_k=n$ ，前面k-1个数已经确定了，那么也就确定了第k个数。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	arr[++len] = <span class="number">1</span>;</span><br><span class="line">	count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (len) &#123;</span><br><span class="line">		<span class="keyword">if</span> (len &lt; (k<span class="number">-1</span>)) &#123;</span><br><span class="line">			arr[len + <span class="number">1</span>] = arr[len];</span><br><span class="line">			len++;</span><br><span class="line">			count += arr[len];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">int</span> flag = arr[len];</span><br><span class="line">			len--;</span><br><span class="line">			count -= flag;</span><br><span class="line">			<span class="keyword">while</span> (len&amp;&amp;(flag == ((n - count) / (k - len)))) &#123;</span><br><span class="line">				flag = arr[len];</span><br><span class="line">				len--;</span><br><span class="line">				count -= flag;</span><br><span class="line">			&#125;</span><br><span class="line">			flag++;</span><br><span class="line">			<span class="keyword">if</span> (flag&lt;=((n-count)/(k-len))) &#123;</span><br><span class="line">				arr[len + <span class="number">1</span>] = flag;</span><br><span class="line">				len++;</span><br><span class="line">				count += flag;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1024（一元三次方程求解）</title>
    <url>/2020/08/14/P1024/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有形如：$ax^3+bx^2+cx^1+dx^0=0$这样的一个一元三次方程。给出该方程中各项的系数(a,b,c,d均为实数)，并约定该方程存在三个不同实根(根的范围在−100至100之间)，且根与根之差的绝对值大于或等于1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。   </p>
<p>提示：记方程f(x)=0，若存在2个数$x_1$和$x_2$，且$x_1 &lt; x_2,f(x_1)\times f(x_2)&lt;0$,则在$(x_1,x_2)$之间一定有一个根。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一行，4个实数A,B,C,D。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行，3个实根，并精确到小数点后2位。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>由盛金公式解的   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">double</span> a,b,c,d;</span><br><span class="line">     <span class="keyword">double</span> as,bs,t,si;</span><br><span class="line">     <span class="keyword">double</span> x1,x2,x3;</span><br><span class="line">     cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">     as=b*b<span class="number">-3</span>*a*c;</span><br><span class="line">     bs=b*c<span class="number">-9</span>*a*d;</span><br><span class="line">     t=(<span class="number">2</span>*as*b<span class="number">-3</span>*a*bs)/(<span class="number">2</span>*<span class="built_in">sqrt</span>(as*as*as));</span><br><span class="line">     si=<span class="built_in">acos</span>(t);</span><br><span class="line">     x1=(-b<span class="number">-2</span>*<span class="built_in">sqrt</span>(as)*<span class="built_in">cos</span>(si/<span class="number">3</span>))/(<span class="number">3</span>*a);</span><br><span class="line">     x2=(-b+<span class="built_in">sqrt</span>(as)*(<span class="built_in">cos</span>(si/<span class="number">3</span>)+<span class="built_in">sqrt</span>(<span class="number">3</span>)*<span class="built_in">sin</span>(si/<span class="number">3</span>)))/(<span class="number">3</span>*a);</span><br><span class="line">     x3=(-b+<span class="built_in">sqrt</span>(as)*(<span class="built_in">cos</span>(si/<span class="number">3</span>)-<span class="built_in">sqrt</span>(<span class="number">3</span>)*<span class="built_in">sin</span>(si/<span class="number">3</span>)))/(<span class="number">3</span>*a);</span><br><span class="line">     cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;x1&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">     cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;x3&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">     cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;x2&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1026（统计单词个数）</title>
    <url>/2020/08/14/P1026/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个长度不超过 200 的由小写英文字母组成的字母串（该字串以每行 20 个字母的方式输入，且保证每行一定为 20 个）。要求将此字母串分成 k份，且每份中包含的单词个数加起来总数最大。   </p>
<p>每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串 this 中可包含 this 和 is，选用 this 之后就不能包含 th。<br>单词在给出的一个不超过 6 个单词的字典中。<br>要求输出最大的个数。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>每组的第一行有两个正整数 p,k。 p 表示字串的行数，k 表示分为 k 个部分。    </p>
<p>接下来的 p 行，每行均有 20 个字符。    </p>
<p>再接下来有一个正整数 s，表示字典中单词个数。 接下来的 s 行，每行均有一个单词。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>1个整数，分别对应每组测试数据的相应结果。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 $ 100% $ 的数据，$ 2 \le k \le 40 ，1 \le s \le 6 $。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题用两个动态规划就可以解决了，我还多用了一个滚动数组。   </p>
<p>第一步是输入，这个是必须要做的，没啥说的，输入p,k。根据p按行输入一个字符串str，然后 int len=str.size()一下，这个后面要用的，之后输入s，再输入一个word数组。   </p>
<p>之后是预处理，用w[i][j]表示str从i到j中单词个数。先构造出w[i][i]，之后递推式：w[i-1][j]=w[i][j]，如果str中从i-1到j的子串中存在一个单词从i-1位置开始，那么w[i-1][j]再加一。这里可以用string类的find函数，返回值是0的话就加一。用f[i][j]表示把前i个字符分成j段最多的单词个数，要先处理f[i][i]，$f[i][i]=\sum_{k=1}^{i}w[k][k]$，之后就是一个递推式f[i][j]=max(f[i][j],f[r][j-1]+w[r+1][i])，这里的r满足$(j-1)\le r\le (i-1)$。   </p>
<p>最后一步就是输出，输出f[len][k]就好了。     </p>
<p>为什么要用到滚动数组呢，请看f数组部分，第k列只与第k-1列有关，同理，第k-1列只与第k-2列有关···那么我们就可以建立一个滚动数组，同时有个小技巧，f数组的第k列我们只取了f[len][k]，其它都是没用的，所以我们滚动数组处理的时候只要处理到k-1步就可以了，第k简化成只求一个数了。     </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> p, k, s;</span><br><span class="line">string word[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">202</span>][<span class="number">202</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">202</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(string st)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (st.<span class="built_in">find</span>(word[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; p &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p;i++) &#123;</span><br><span class="line">		string st;</span><br><span class="line">		cin &gt;&gt; st;</span><br><span class="line">		str = str + st;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s;i++) &#123;</span><br><span class="line">		cin &gt;&gt; word[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">			w[j][i] = w[j + <span class="number">1</span>][i];</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">			string st = str.<span class="built_in">substr</span>(j - <span class="number">1</span>, i - j + <span class="number">1</span>);</span><br><span class="line">			w[j][i] += <span class="built_in">check</span>(st);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) &#123;</span><br><span class="line">		f[i][b] = w[<span class="number">1</span>][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">2</span>;cs &lt; k;cs++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = cs;i &lt;= len;i++) &#123;</span><br><span class="line">			f[i][!b] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = cs - <span class="number">1</span>;j &lt; i;j++) &#123;</span><br><span class="line">				f[i][!b] = <span class="built_in">max</span>(f[i][!b], f[j][b] + w[j + <span class="number">1</span>][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		b = !b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (k - <span class="number">1</span>);i &lt; len;i++) &#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, f[i][b] + w[i + <span class="number">1</span>][len]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1027（Car的旅行路线）</title>
    <url>/2020/08/14/P1027/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。   </p>
<p>她知道每个城市都有 4 个飞机场，分别位于一个矩形的 4 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 i 个城市中高速铁路了的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 t。     </p>
<p>那么 Car 应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。    </p>
<p>找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行为一个正整数 n，表示有 n 组测试数据。   </p>
<p>每组的第一行有 4 个正整数 s,t,A,B。   </p>
<p>S 表示城市的个数，t 表示飞机单位里程的价格，A，B 分别为城市A，B 的序号。   </p>
<p>接下来有 S 行，其中第 i 行均有 7 个正整数$x_{i1},y_{i1},x_{i2},y_{i2},x_{i3},y_{i3},T_i$ ，这当中的 $(x_{i1},y_{i1}),(x_{i2},y_{i2})，(x_{i3},y_{i3})$分别是第 i 个城市中任意 3 个机场的坐标，$T_i$为第 i 个城市高速铁路单位里程的价格。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共有 n 行，每行 1 个数据对应测试数据。  </p>
<p>保留一位小数。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 $ 100% $ 的数据，$1\le n \le 10，1\le S \le 100，1\le A,B \le S $</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>我们把每个城市看成4个点，简单的spfa就好了。   </p>
<p>对于每一次测试，都可以共用三个数组，一个是用来记录各个点的坐标的数组，一个是记录点与点之间距离的数组，还有一个是记录城市四个点之间高速的里程费用，我看到一些人还要memset，但是如果相同位置两次测试都要用到，那么后一次测试就会覆盖，如果用不到，那也不会对后一次测试造成影响。    </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> map[<span class="number">401</span>][<span class="number">401</span>];</span><br><span class="line"><span class="keyword">int</span> point[<span class="number">401</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> T[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_point</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1 = point[j][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> y1 = point[j][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> x2 = point[j + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> y2 = point[j + <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> x3 = point[j + <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> y3 = point[j + <span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> len12 = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2);</span><br><span class="line">	<span class="keyword">int</span> len23 = (x2 - x3)*(x2 - x3) + (y2 - y3)*(y2 - y3);</span><br><span class="line">	<span class="keyword">int</span> len13 = (x1 - x3)*(x1 - x3) + (y1 - y3)*(y1 - y3);</span><br><span class="line">	<span class="keyword">if</span> (len12 == (len23 + len13)) &#123;</span><br><span class="line">		point[j + <span class="number">3</span>][<span class="number">0</span>] = x1 + x2 - x3;</span><br><span class="line">		point[j + <span class="number">3</span>][<span class="number">1</span>] = y1 + y2 - y3;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len23 == (len12 + len13)) &#123;</span><br><span class="line">		point[j + <span class="number">3</span>][<span class="number">0</span>] = x2 + x3 - x1;</span><br><span class="line">		point[j + <span class="number">3</span>][<span class="number">1</span>] = y2 + y3 - y1;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len13 == (len12 + len23)) &#123;</span><br><span class="line">		point[j + <span class="number">3</span>][<span class="number">0</span>] = x1 + x3 - x2;</span><br><span class="line">		point[j + <span class="number">3</span>][<span class="number">1</span>] = y1 + y3 - y2;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; s;k++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">				map[k][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!(map[k][j])) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j != k) &#123;</span><br><span class="line">					<span class="keyword">double</span> len = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(point[j][<span class="number">0</span>] - point[k][<span class="number">0</span>], <span class="number">2</span>) + <span class="built_in">pow</span>(point[j][<span class="number">1</span>] - point[k][<span class="number">1</span>], <span class="number">2</span>));</span><br><span class="line">					<span class="keyword">if</span> ((j / <span class="number">4</span>) == (k / <span class="number">4</span>)) &#123;</span><br><span class="line">						len *= T[j / <span class="number">4</span>];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						len *= t;</span><br><span class="line">					&#125;</span><br><span class="line">					map[j][k] = len;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				map[j][k] = map[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> dis[<span class="number">401</span>];</span><br><span class="line">	<span class="keyword">bool</span> use[<span class="number">401</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s;i++) &#123;</span><br><span class="line">		dis[i] = <span class="number">99999999.9999</span>;</span><br><span class="line">		use[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[a] = <span class="number">0</span>;</span><br><span class="line">	use[a] = <span class="literal">true</span>;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(a);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		use[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == x) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((dis[x] + map[x][i]) &lt; dis[i]) &#123;</span><br><span class="line">				dis[i] = dis[x] + map[x][i];</span><br><span class="line">				<span class="keyword">if</span> (!use[i]) &#123;</span><br><span class="line">					use[i] = <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_spfa</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">999999</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, <span class="built_in">spfa</span>(<span class="number">4</span> * a + i, <span class="number">4</span> * b + j, s));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s, t, a, b;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; t &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	a--;</span><br><span class="line">	b--;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span> * s;j += <span class="number">4</span>) &#123;</span><br><span class="line">		cin &gt;&gt; point[j][<span class="number">0</span>] &gt;&gt; point[j][<span class="number">1</span>] &gt;&gt; point[j + <span class="number">1</span>][<span class="number">0</span>] &gt;&gt; point[j + <span class="number">1</span>][<span class="number">1</span>] &gt;&gt; point[j + <span class="number">2</span>][<span class="number">0</span>] &gt;&gt; point[j + <span class="number">2</span>][<span class="number">1</span>] &gt;&gt; T[j / <span class="number">4</span>];</span><br><span class="line">		<span class="built_in">get_point</span>(j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">4</span> * s, t);</span><br><span class="line">	<span class="built_in">test_spfa</span>(a, b, <span class="number">4</span> * s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1029（最大公约数和最小公倍数问题）</title>
    <url>/2020/08/14/P1029/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个正整数 $x_0, y_0$，求出满足下列条件的 P,Q 的个数：<br>1.P,Q 是正整数。<br>2.要求 P, Q 以 $x_0$ 为最大公约数，以 $y_0$为最小公倍数。   </p>
<p>试求：满足条件的所有可能的 P, Q的个数。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一行两个正整数 $x_0, y_0$。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行一个数，表示求出满足条件的 P, Q 的个数。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题我是参考了别人的代码思路，我们可以看到不管哪一个P,Q它们都满足$P\times Q=x_0 \times y_0$，那么我们可以先用一个q表示$y_0$ 除以$x_0$的值（如果不能整除，输出0就可以了），然后从2开始看q能整除哪些数，用一个ans记录下来，最后输出ans的2次方就可以了，这里我模仿那位大佬的方法，左移一位代表2的次方。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="keyword">if</span> ((y%x) != <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> q = y / x;</span><br><span class="line">		<span class="keyword">int</span> begin = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (q &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((q%begin) == <span class="number">0</span>) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">while</span> ((q%begin) == <span class="number">0</span>) &#123;</span><br><span class="line">					q /= begin;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; (<span class="number">1</span> &lt;&lt; ans) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1028（数的计算）</title>
    <url>/2020/08/14/P1028/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们要求找出具有下列性质数的个数(包含输入的正整数 n)。   </p>
<p>先输入一个正整数 $n(n \le 1000)$,然后对此正整数按照如下方法进行处理：<br>1.不作任何处理；<br>2.在它的左边加上一个正整数,但该正整数不能超过原数的一半；<br>3.加上数后,继续按此规则进行处理,直到不能再加正整数为止。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>1 个正整数 $n(n \le 1000)$</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>1 个整数，表示具有该性质数的个数。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这题最基本的做法就是深度搜索了，然而大家想过没有，大家可以去推导一个递推式，设我们要去的为$a_n$，那么$a_n$左边能接的就是$a_1,a_2,a_3······a_{[ n/2]}$，这里的[] 是向下取整，那么可以推导出出$a_n=\sum_{i=1}^{[ n/2]}a_i+1$的公式，记得加一，因为n本身可以不往左边加数字，那么它本身也是一个符合的数字。这样的话，复杂度就降到了$O(n/2)$。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">501</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">501</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> t = n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t;i++) &#123;</span><br><span class="line">		arr[i] = sum[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (sum[t] + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1030（求先序排列）</title>
    <url>/2020/08/14/P1030/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度$\le 8$）。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>2行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>1行，表示一棵二叉树的先序。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这是一道二叉树的题目，当时老师是布置过这个题目的，但是我当时是用递归做的，但是我当时年轻，老师问了一句如果数据量10000000个，你又怎么处理呢，我当时提出了一个解法，好像和二叉排序树相关，转眼半年过去了，原解法已经忘了，现在想的这个解法也许是新解法？     </p>
<p>我们可以每次对中序序列的$l_1 \sim r_1$的范围和后序序列的$l_2 \sim r_2$的范围内搜索，在中序序列中找到后序序列中$r_2$位置上的节点，假设它在中序序列中对应下标为p,中序序列裂变成$l_1\sim (p-1)$和$(p+1) \sim r_1$两部分，后序遍历裂变成$l_2\sim (l_2+p-1-l_1)$和$(l_2+p-l_1)\sim (r2-1)$两部分，然后继续向下分裂，直到不能分裂为止，注意，每次分裂时，都要把p位置上节点的值输出一次，因为后序序列的最后一个节点就是先序序列的第一个节点。这题数据量特别小，递归应该能过，但是我害怕10000000的数据量，所以我选择非递归做法，并且用数组模拟了栈。    </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str1, str2;<span class="comment">//str1:中序,str2：后序</span></span><br><span class="line"><span class="keyword">int</span> node[<span class="number">10</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">	<span class="keyword">int</span> s = str1.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	node[num][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	node[num][<span class="number">1</span>] = --s;</span><br><span class="line">	node[num][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	node[num++][<span class="number">3</span>] = s;</span><br><span class="line">	<span class="keyword">while</span> (num) &#123;</span><br><span class="line">		<span class="keyword">int</span> l1 = node[--num][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> r1 = node[num][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> l2 = node[num][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> r2 = node[num][<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">int</span> begin = l1;</span><br><span class="line">		<span class="keyword">while</span> (str1[begin] != str2[r2]) &#123;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; str2[r2];</span><br><span class="line">		<span class="keyword">if</span> (r1 &gt; begin) &#123;</span><br><span class="line">			node[num][<span class="number">0</span>] = begin + <span class="number">1</span>;</span><br><span class="line">			node[num][<span class="number">1</span>] = r1;</span><br><span class="line">			node[num][<span class="number">2</span>] = l2 + begin - l1;</span><br><span class="line">			node[num++][<span class="number">3</span>] = --r2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (begin &gt; l1) &#123;</span><br><span class="line">			node[num][<span class="number">0</span>] = l1;</span><br><span class="line">			node[num][<span class="number">1</span>] = begin - <span class="number">1</span>;</span><br><span class="line">			node[num][<span class="number">2</span>] = l2;</span><br><span class="line">			node[num++][<span class="number">3</span>] = l2 + begin - <span class="number">1</span> - l1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1031（均分纸牌）</title>
    <url>/2020/08/14/P1031/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有N堆纸牌，编号分别为 1,2,…,N。每堆上有若干张，但纸牌总数必为N的倍数。可以在任一堆上取若干张纸牌，然后移动。    </p>
<p>移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N的堆上取的纸牌，只能移到编号为N−1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。   </p>
<p>现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。</p>
<p>例如N=4，4堆纸牌数分别为：<br>9，8，17，6</p>
<p>移动3次可达到目的：</p>
<p>从第三堆取4张牌给第四堆，从第三堆取3张牌给第二堆，从第二堆取1张牌给第一堆。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>两行</p>
<p>第一行为：N（N 堆纸牌，$1 \le N \le 100 $）</p>
<p>第二行为：$A_1,A_2, … ,A_n $（N堆纸牌，每堆纸牌初始数，$ 1 \le A_i \le 10000 $）</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行：即所有堆均达到相等时的最少移动次数。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>假设所有堆上的牌有s张，那么每个堆应该分配$ \frac{s}{n} $张牌，我们可以从第一堆牌出发，先让第一堆牌上的牌数减去$ \frac{s}{n} $，如果等于0，就说明第一堆牌不需要别的牌堆给牌，同时，他也给不了别的牌堆牌，如果小于0呢，就说明它上面的牌数是少于$ \frac{s}{n} $的，那么需要2号牌堆给他牌，如果大于0，就需要给予2号牌堆多出来的牌，无论是小于0还是大于0，都需要移动一次，所以移动次数需要加一。这时候，1号牌堆已经处理完毕，同样的方法去处理2号牌堆，注意，前面我们已经处理好了1号牌堆，1号牌堆是不能给予或接受牌的了，如果2号牌堆上的牌数不等于$ \frac{s}{n} $，那也只能被3号牌堆给予牌或给予牌给3号牌堆，且移动次数要加一，一直处理到n-1号牌堆，为什么是n-1而不是n呢，因为题目中说了s是n的倍数，所以如果前面n-1堆牌都调整到了$ \frac{s}{n} $，那么第n堆牌上的牌数一定也是$ \frac{s}{n} $。</p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">101</span>];</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">		sum += arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sum /= n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		arr[i] -= sum;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			arr[i + <span class="number">1</span>] += arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1032(字串变换)</title>
    <url>/2020/10/31/P1032/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则）:</p>
<p>$A_1\rightarrow B_1$<br>​<br>$A_2\rightarrow B_2$ </p>
<p>规则的含义为：在 $A$ 中的子串 $A_1$可以变换为 $B_1$，$A_2$可以变换为 $B_2$…。</p>
<p>例如：$A=\text{abcd}$，$B＝\text{xyz}$，</p>
<p>变换规则为：</p>
<p>$\text{abc}\rightarrow\text{xu}，\text{ud}\rightarrow\text{y}，\text{y}\rightarrow\text{yz}$</p>
<p>则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：</p>
<p>$\text{abcd}\rightarrow\text{xud}\rightarrow\text{xy}\rightarrow\text{xyz}$。</p>
<p>共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入格式如下：</p>
<p>$A$ $B$</p>
<p>$A_1$ $B_1$</p>
<p>$A_2$ $B_2$ </p>
<p>变换规则</p>
<p>… …</p>
<p>所有字符串长度的上限为 $20$</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>若在 $10$ 步（包含 $10$ 步）以内能将 $A$ 变换为 $B$，则输出最少的变换步数；否则输出NO ANSWER!</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>用广度搜索就可以了，简单过</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 15</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="comment">//方便搜索，也可以使用pair简化</span></span><br><span class="line">	string str;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string a, b;</span><br><span class="line">string orginal[maxn];</span><br><span class="line">string translated[maxn];</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; ma;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">trans</span><span class="params">(<span class="keyword">const</span> string &amp;str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (i + orginal[j].<span class="built_in">length</span>() &gt; str.<span class="built_in">length</span>())</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; orginal[j].<span class="built_in">length</span>();k++)</span><br><span class="line">		<span class="keyword">if</span> (str[i + k] != orginal[j][k])</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">	ans = str.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">	ans += translated[j];</span><br><span class="line">	ans += str.<span class="built_in">substr</span>(i + orginal[j].<span class="built_in">length</span>());</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue &lt;node&gt; q;</span><br><span class="line">	node s;</span><br><span class="line">	s.str = a;</span><br><span class="line">	s.step = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		node u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		string temp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ma.<span class="built_in">count</span>(u.str) == <span class="number">1</span>) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (u.str == b) &#123;</span><br><span class="line">			ans = u.step;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ma[u.str] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; u.str.<span class="built_in">length</span>();i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">				temp = <span class="built_in">trans</span>(u.str, i, j);</span><br><span class="line">				<span class="keyword">if</span> (temp != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">					node v;</span><br><span class="line">					v.str = temp;</span><br><span class="line">					v.step = u.step + <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans &gt; <span class="number">10</span> || ans == <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO ANSWER!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; orginal[n] &gt;&gt; translated[n])</span><br><span class="line">		n++;</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>P1084（疫情控制）</title>
    <url>/2020/08/14/P1084/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>H 国有 n个城市，这 n 个城市用n−1条双向道路相互连通构成一棵树，1号城市是首都，也是树中的根节点。   </p>
<p>H国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。   </p>
<p>现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。   </p>
<p>请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行一个整数n，表示城市个数。   </p>
<p>接下来的 n−1 行，每行3个整数，u,v,w，每两个整数之间用一个空格隔开，表示从城市 u到城市v 有一条长为 w 的道路。数据保证输入的是一棵树，且根节点编号为 1。   </p>
<p>接下来一行一个整数 m，表示军队个数。    </p>
<p>接下来一行 m个整数，每两个整数之间用一个空格隔开，分别表示这 m 个军队所驻扎的城市的编号。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出-1。</p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>保证军队不会驻扎在首都。</p>
<p>对于 20%的数据，$2 \le n \le 10$；</p>
<p>对于 40%的数据，$2 \le n \le 50,0&lt; w &lt; 10^5$；</p>
<p>对于 60%的数据，$2 \le n \le 1000,0&lt; w &lt; 10^6$ ；</p>
<p>对于 80%的数据，$2 \le n \le 10000 $；</p>
<p>对于 100%的数据，$2\le m\le n\le 50000,0&lt; w &lt; 10^9 $。</p>
<h1 id="解题感悟"><a href="#解题感悟" class="headerlink" title="解题感悟"></a>解题感悟</h1><p>这一题是我和洛谷的结缘题，是在做了这题后才开始迈入洛谷的ac路，然而我都大二了，还是菜鸡一个。    </p>
<p>这题是一个二分法去做，因为题目的解是一个线性的，好像求一根直线与x轴的交点一样，非常的巧妙。我一开始是不会做的，是看了大佬们的题解后，摸索了3天才理解了个大概。   </p>
<p>Talking is cheap,show you my code.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;<span class="comment">//边的数量*2</span></span><br><span class="line"><span class="keyword">int</span> help_army_number = <span class="number">0</span>;<span class="comment">//调整后可用军队数</span></span><br><span class="line"><span class="keyword">int</span> need_city_number = <span class="number">0</span>;<span class="comment">//调整后仍需要驻扎子节点数</span></span><br><span class="line"><span class="keyword">int</span> army_number = <span class="number">0</span>;<span class="comment">//调整前到达根节点的军队数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nn = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//军队数</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//城市数</span></span><br><span class="line"><span class="keyword">int</span>  ver[<span class="number">2</span>*N];<span class="comment">//ver[tot]:存储第tot次add的y值</span></span><br><span class="line"><span class="keyword">int</span> edge[<span class="number">2</span>*N];<span class="comment">//edge[tot]:存储第tot次add的z值</span></span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">2</span>*N];<span class="comment">//Next[tot]:存储第tot次add的x值上一次的tot&#x27;值</span></span><br><span class="line"><span class="keyword">int</span> head[N];<span class="comment">//head[x]:存储x值最后一次add对应的tot值</span></span><br><span class="line"><span class="keyword">int</span> army[N];<span class="comment">//army[i]:第i号军队的军队位置</span></span><br><span class="line"><span class="keyword">int</span> deep[N];<span class="comment">//deep[i]:第i号城市的深度</span></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">20</span>];<span class="comment">//f[i][j]:第i个节点第2^j个组先节点编号</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dist[N][<span class="number">20</span>];<span class="comment">//dist[i][j]:第i个到它第2^j个节点的路径距离</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l_time = <span class="number">0</span>;<span class="comment">//二分搜索的初始左边界</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r_time = <span class="number">0</span>;<span class="comment">//二分搜索的初始右边界</span></span><br><span class="line"><span class="keyword">bool</span> stay[N];<span class="comment">//stay[i]:i号城市是否有军队驻扎，有则stay[i]=1,否则stay[i]=0</span></span><br><span class="line"><span class="keyword">bool</span> need[N];<span class="comment">//need[i]:i号城市需要军队驻扎</span></span><br><span class="line"><span class="keyword">int</span> tim[N];<span class="comment">//tim[i]:重新调整军队后仍停留在根节点的军队的可用距离,这里没有记录这个军队从哪里来</span></span><br><span class="line"><span class="keyword">int</span> ned[N];<span class="comment">//ned[i]:城市i在重新调整军队后仍然处于无军队驻扎,ned[i]=1,否则，ned[i]=0</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;<span class="comment">//最后时间</span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; h[N];<span class="comment">//h[i].first:该军队到达根节点后还有余力走多远;h[i].second:该军队从根节点的哪个子节点来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q = <span class="number">0</span>; <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>)ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>)q = q * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;<span class="comment">//读入函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_line</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	ver[tot] = y ;</span><br><span class="line">	edge[tot] = z;</span><br><span class="line">	Next[tot] = head[x];</span><br><span class="line">	head[x] = tot;</span><br><span class="line">&#125;<span class="comment">//添加一条边，(u,v,w)=(x,y,z)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mystack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	deep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!mystack.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = mystack.<span class="built_in">top</span>();</span><br><span class="line">		mystack.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x];i;i = Next[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = ver[i];</span><br><span class="line">			<span class="keyword">if</span> (!deep[y]) &#123;</span><br><span class="line">				deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">				f[y][<span class="number">0</span>] = x;</span><br><span class="line">				<span class="keyword">int</span> k = f[y][<span class="number">0</span>];</span><br><span class="line">				dist[y][<span class="number">0</span>] = edge[i];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;nn;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">					dist[y][j] = dist[y][j - <span class="number">1</span>] + dist[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				mystack.<span class="built_in">push</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//用深度优先搜索方法构造dist数组和f数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> pson = <span class="number">0</span>;<span class="comment">//判断是否为叶子节点</span></span><br><span class="line">	<span class="keyword">if</span> (stay[x])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//若当前节点已被驻扎，则返回1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x];i;i = Next[i])<span class="comment">//遍历x的出边</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> y = ver[i];</span><br><span class="line">		<span class="keyword">if</span> (deep[y] &lt; deep[x])</span><br><span class="line">			<span class="keyword">continue</span>;<span class="comment">//遇到父节点</span></span><br><span class="line">		pson = <span class="number">1</span>;<span class="comment">//若有一条不是连接着父节点的边，说明不是叶子节点</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">dfs</span>(y))<span class="comment">//若某个子节点搜索时遇到路径未被驻扎的叶子节点，直接返回0</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!pson)<span class="comment">//当前节点是叶子节点且未被驻扎</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//没有遇到路径未被驻扎的叶子节点，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(stay, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stay));</span><br><span class="line">	<span class="built_in">memset</span>(tim, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tim));</span><br><span class="line">	<span class="built_in">memset</span>(ned, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ned));</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">	<span class="built_in">memset</span>(need, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(need));</span><br><span class="line">	help_army_number = <span class="number">0</span>;</span><br><span class="line">	need_city_number = <span class="number">0</span>;</span><br><span class="line">	army_number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> x = army[i], cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = nn;j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">			<span class="keyword">if</span> (f[x][j] &gt; <span class="number">1</span> &amp;&amp; cnt + dist[x][j] &lt;= lim)</span><br><span class="line">			&#123;</span><br><span class="line">				cnt += dist[x][j];</span><br><span class="line">				x = f[x][j];</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (f[x][<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; cnt + dist[x][<span class="number">0</span>] &lt;= lim)</span><br><span class="line">			h[++army_number] = <span class="built_in">make_pair</span>(lim - cnt - dist[x][<span class="number">0</span>], x);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			stay[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="comment">//上移军队，能到根节点就到根节点，到不了就停在最浅节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>];i;i = Next[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">dfs</span>(ver[i]))</span><br><span class="line">			need[ver[i]] = <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="comment">//dfs寻找路径未被驻扎的叶子节点</span></span><br><span class="line">	<span class="built_in">sort</span>(h + <span class="number">1</span>, h + army_number + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= army_number;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (need[h[i].second] &amp;&amp; h[i].first &lt; dist[h[i].second][<span class="number">0</span>])</span><br><span class="line">			need[h[i].second] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tim[++help_army_number] = h[i].first;</span><br><span class="line">	&#125;<span class="comment">//对根节点的需要被驻扎的子节点进行初步处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>];i;i = Next[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (need[ver[i]])</span><br><span class="line">			ned[++need_city_number] = dist[ver[i]][<span class="number">0</span>];</span><br><span class="line">	&#125;<span class="comment">//找到仍需要被驻扎的节点并存储</span></span><br><span class="line">	<span class="keyword">if</span> (help_army_number &lt; need_city_number) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(tim + <span class="number">1</span>, tim + help_army_number + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(ned + <span class="number">1</span>, ned + need_city_number + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= need_city_number &amp;&amp; j &lt;= help_army_number) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tim[j] &gt;= ned[i])&#123;</span><br><span class="line">			i++, j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; need_city_number) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//利用贪心策略完成最后的匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">int</span> son = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, z;</span><br><span class="line">		x = <span class="built_in">read</span>();</span><br><span class="line">		y = <span class="built_in">read</span>();</span><br><span class="line">		z = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add_line</span>(x, y, z);</span><br><span class="line">		<span class="built_in">add_line</span>(y, x, z);</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">1</span> || y == <span class="number">1</span>) &#123;</span><br><span class="line">			son++;</span><br><span class="line">		&#125;</span><br><span class="line">		r_time += z;</span><br><span class="line">	&#125;<span class="comment">//输入u,v,w</span></span><br><span class="line">	<span class="built_in">dfs</span>();</span><br><span class="line">	m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">		army[i] = <span class="built_in">read</span>();</span><br><span class="line">		stay[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="comment">//构造军队初始信息</span></span><br><span class="line">	<span class="keyword">if</span> (m &lt; son) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (l_time &lt;= r_time) &#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> mid = (l_time + r_time) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">			r_time = mid - <span class="number">1</span>;</span><br><span class="line">			ans = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l_time = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学A1</title>
    <url>/2022/03/17/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6A1/</url>
    <content><![CDATA[<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="特殊向量"><a href="#特殊向量" class="headerlink" title="特殊向量"></a>特殊向量</h2><ul>
<li>单位向量</li>
<li>零向量<h2 id="向量-1"><a href="#向量-1" class="headerlink" title="向量"></a>向量</h2></li>
<li>加法(平行四边形法则)</li>
<li>数乘</li>
<li>空间距离 $d=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</li>
<li>向量的模 $|r|=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</li>
<li>方向角 假设$a=(a_1,a_2,a_3)$，则$cos(\alpha)=\frac{a_1}{|a|},cos(\beta)=\frac{a_2}{|a|},cos(\gamma)=\frac{a_3}{|a|}$</li>
<li>数量积(标量) $a·b=|a||b|cos(\theta)$</li>
<li>向量积(矢量) $a\times b=|a||b|sin(\theta))$ (右手规则)</li>
<li>混合积(标量) $[abc]=|a\times b||c|cos&lt;a\times b,c&gt;$</li>
<li>三个向量共面的充分必要条件是三个向量的混合积为0<h1 id="空间解析几何"><a href="#空间解析几何" class="headerlink" title="空间解析几何"></a>空间解析几何</h1></li>
<li>平面的一般性方程$A(x-x_0)+B(y-y_0)+C(z-z_0)=0,Ax+By+Cz+D=0$</li>
<li>利用混合积性质，有平面的三点式方程$\begin{vmatrix}x-x_1 &amp; y-y_1 &amp; z-z_1 \ x_2-x_1 &amp; y_2-y_1 &amp; z_2-z_1\ x_3-x_1 &amp; y_3-y_1 &amp; z_3-z_1\end{vmatrix}$</li>
<li>平面的截距式方程$\frac{x}{a}+\frac{y}{b}+\frac{z}{c}=1$</li>
<li>直线的参数式方程 $\begin{cases} x=x_0+t\times l\ y=y_0+t\times m \ z=z_0+t\times n\end{cases} ,t \in R$</li>
<li>直线的对称式方程(标准方程)$\frac{x-x_0}{l}=\frac{y-y_0}{m}=\frac{z-z_0}{n},l^2+m^2+n^2\neq 0$</li>
<li>因为两平面相交确定一条直线，所以有直线的一般性方程$\begin{cases}A_1x+B_1y+C_1z+D_1=0\ A_2x+B_2y+C_2z+D_2=0\end{cases}$</li>
<li>点到平面的距离 $d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}$</li>
<li>两平面法向量的夹角$\theta$称为两平面的夹角$(0\leq \theta \leq \frac{\pi}{2}),cos\theta=\frac{|n_1·n_2|}{|n_1||n_2|}=\frac{|A_1A_2+B_1B_2+C_1C_2|}{\sqrt{A_1^2+B_1^2+C_1^2} \sqrt{A_2^2+B_2^2+C_2^2}}$</li>
<li>两平面垂直的充要条件$A_1A_2+B_1B_2+C_1C_2=0$</li>
<li>两平面平行的充要条件$\frac{A_1}{A_2}=\frac{B_1}{B_2}=\frac{C_1}{C_2}$</li>
<li>两直线垂直的充要条件$l_1l_2+m_1m_2+n_1n_2=0$</li>
<li>两直线平行的充要条件$\frac{l_1}{l_2}=\frac{m_1}{m_2}=\frac{n_1}{n_2}$</li>
<li>球面方程$(x-x_0)^2+(y-y_0)^2+(z-z_0)^2=R^2$</li>
<li>椭球面方程$\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1$</li>
<li>双曲抛物面方程$\frac{x^2}{a^2}-\frac{y^2}{b^2}=2z$</li>
<li>空间中曲线可以看成两个曲面的交线，所以应满足方程$\begin{cases} F(x,y,z)=0\ G(x,y,z)=0\end{cases}$,也可以是$\begin{cases}x=f(t)\ y=g(t)\ z=h(t) \end{cases}$<h1 id="函数、极限、连续"><a href="#函数、极限、连续" class="headerlink" title="函数、极限、连续"></a>函数、极限、连续</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2></li>
<li>特殊集合：空集</li>
<li>运算：并集、交集、差集</li>
<li>笛卡尔乘积：${(x,y)|x\in A,y \in B}$为A与B的直积，记为$A\times B$</li>
<li>点a的领域：$O(a,\delta)={x| |x-a|&lt;\delta}=(a-\delta,a+\delta)$</li>
<li>点a的去心领域：$O_0(a,\delta)={x| 0&lt;|x-a|&lt;\delta}=(a-\delta,a+\delta)-{a}$</li>
<li>点a的右领域：$O^+(a,\delta)={x| 0&lt;x-a&lt;\delta}=(a,a+\delta)$</li>
<li>点a的左领域：$O^-(a,\delta)={x| -\delta&lt;x-a&lt;0}=(a-\delta,a)$</li>
<li>上界：如果存在一个实数M，使得$\forall x\in A,x\leq M$，则称M为A的上界，最小的上界为上确界(supA)</li>
<li>下界：如果存在一个实数M，使得$\forall x\in A,x\geq M$，则称M为A的下界，最大的下界为下确界(infA)</li>
<li>确界存在定理：非空有上界的实数集A必有上确界，非空有下界的实数解必有下确界<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li>
<li>映射：单射、满射、双射</li>
<li>周期性、有界性、奇偶性</li>
<li>复合函数</li>
<li>反函数</li>
<li>基本初等函数：幂函数、指数函数、对数函数、三角函数、反三角函数<h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2></li>
<li>数列极限：收敛必有界，单调有界必收敛</li>
<li>夹逼定理</li>
<li>$lim_{x\to 0}\frac{sinx}{x}=1$</li>
<li>$lim_{x\to \infty }(1+\frac{1}{x})^x=e$</li>
<li>高阶无穷小：$\alpha(x)=o(\beta(x))$</li>
<li>同阶无穷小:$\alpha(x)=O(\beta(x))$，当两者为等价无穷小时，$\alpha(x)~\beta(x)$</li>
<li>k阶无穷小：$lim_{x\to \alpha}\frac{\alpha{x}}{\beta^k(x)}$</li>
<li>连续</li>
<li>第一类间断点：可去间断点、跳跃间断点</li>
<li>第二类间断点</li>
<li>有界性定理：若$f(x)\in C[a,b]$,则f(x)在[a.b]上必有界</li>
<li>最大值和最小值定理：若$f(x)\in C[a,b]$,则f(x)在[a.b]上必有最大值和最小值</li>
<li>零点定理：若$f(x)\in C[a,b]$，且f(a)·f(b)&lt;0，则f(x)在开区间(a,b)内必有一零点。<h1 id="导数与微分"><a href="#导数与微分" class="headerlink" title="导数与微分"></a>导数与微分</h1></li>
<li>若f(x)在$x_0$处可导，则f(x)在$x_0$处连续<h1 id="中值定理与导数的应用"><a href="#中值定理与导数的应用" class="headerlink" title="中值定理与导数的应用"></a>中值定理与导数的应用</h1><h2 id="Fermat定理"><a href="#Fermat定理" class="headerlink" title="Fermat定理"></a>Fermat定理</h2>设函数f(x)在点$x_0$的某个领域内有定义，若点$x_0$处可导，且在$x_0$处取得极大值或极小值，则必有$f(x_0)’=0$<h2 id="Rolle中值定理"><a href="#Rolle中值定理" class="headerlink" title="Rolle中值定理"></a>Rolle中值定理</h2>若函数f(x)满足以下三条要求：</li>
<li>在闭区间[a,b]上连续</li>
<li>在开区间(a,b)上可导</li>
<li>f(a)=f(b)</li>
</ul>
<p>则在开区间(a,b)内至少存在一点$x_0$,则$f(x_0)’=0$</p>
<h2 id="Lagrange中值定理"><a href="#Lagrange中值定理" class="headerlink" title="Lagrange中值定理"></a>Lagrange中值定理</h2><p>若f(x)满足以下两条要求：</p>
<ul>
<li>在闭区间[a,b]上连续</li>
<li>在开区间(a,b)上可导</li>
</ul>
<p>则在开区间(a,b)上至少存在一点$x_0$满足$f(x_0)’=\frac{f(b)-f(a)}{b-a}$</p>
<h2 id="Cauchy中值定理"><a href="#Cauchy中值定理" class="headerlink" title="Cauchy中值定理"></a>Cauchy中值定理</h2><p>若函数f(x),g(x)满足</p>
<ul>
<li>f(x),g(x)在闭区间[a,b]内连续</li>
<li>f(x),g(x)在开区间(a,b)内可导</li>
</ul>
<p>则在开区间(a,b)内至少存在一点$x_0$，满足$\frac{f(x_0)’}{g(x_0)’}=\frac{f(b)-f(a)}{g(b)-g(a)}$</p>
<h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><p>$f(x)=\sum_{i=0}^{\infty}f(x_0)^{(i)}(x-x_0)^{i}$</p>
<h2 id="函数单调性"><a href="#函数单调性" class="headerlink" title="函数单调性"></a>函数单调性</h2><p>设函数f(x)在区间[a,b]上连续，在(a,b)内可导，则函数f(x)在区间[a,b]上严格单调增加(或减少)的充要条件是$f’(x)\geq 0(f’(x)\leq 0),x\in (a,b)$,而且在(a,b)内的任何子区间上f’(x)不恒为零</p>
<h2 id="函数极值的判定"><a href="#函数极值的判定" class="headerlink" title="函数极值的判定"></a>函数极值的判定</h2><h3 id="极值的第一充分条件"><a href="#极值的第一充分条件" class="headerlink" title="极值的第一充分条件"></a>极值的第一充分条件</h3><p>若函数f(x)在$x_0$的某个领域内连续，则有：</p>
<ul>
<li>若在 $ x&lt;x_0 $时，有$f’(x)&gt;0$,在$x&gt;x_0$时，有$f’(x)&lt;0$,则函数f(x)在$x_0$处取得极大值</li>
<li>若在 $ x&lt;x_0 $时，有$f’(x)&lt;0$,在$x&gt;x_0$时，有$f’(x)&gt;0$,则函数f(x)在$x_0$处取得极小值<h3 id="极值的第二充分条件"><a href="#极值的第二充分条件" class="headerlink" title="极值的第二充分条件"></a>极值的第二充分条件</h3>设函数f(x)在$x_0$处具有二阶导数，并且$f’(x_0)=0,f”(x_0)\neq 0$，则有</li>
<li>当$f”(x_0)&lt;0$时，函数$f(x_0)$在$x_0$处取得极大值</li>
<li>当$f”(x_0)&gt;0$时，函数$f(x_0)$在$x_0$处取得极小值<h2 id="函数的凹凸性"><a href="#函数的凹凸性" class="headerlink" title="函数的凹凸性"></a>函数的凹凸性</h2>设函数f(x)在[a,b]上连续，在(a,b)内具有二阶导数，则有</li>
<li>当$f”(x)\geq 0$时，函数f(x)在[a,b]上是凹函数</li>
<li>当$f”(x)\leq 0$时，函数f(x)在[a,b]上是凸函数<h2 id="曲率"><a href="#曲率" class="headerlink" title="曲率"></a>曲率</h2>$K=|\frac{y”}{(\sqrt{1+y’^{2}})^3}|=\frac{|x’(t)y”(t)-x”(t)y’(t)|}{(\sqrt{x’(t)^2+y’(t)^2})^3}$<h1 id="一元函数的不定积分"><a href="#一元函数的不定积分" class="headerlink" title="一元函数的不定积分"></a>一元函数的不定积分</h1></li>
<li>第一换元法:$\int f[\varphi(x)]\varphi ‘(x)dx=[\int f(u)du]_{u=\varphi(x)}$</li>
<li>第二换元法:$ \int f(x)dx=[\int f[\varphi(t)]\varphi ‘(t)]_{t=\varphi ^{-1}(x)} $</li>
<li>分步积分法:$\int udv=uv-\int vdu$<h1 id="一元函数定积分"><a href="#一元函数定积分" class="headerlink" title="一元函数定积分"></a>一元函数定积分</h1><h2 id="牛顿-莱布尼兹公式"><a href="#牛顿-莱布尼兹公式" class="headerlink" title="牛顿-莱布尼兹公式"></a>牛顿-莱布尼兹公式</h2>设函数 $f(x)\in C[a,b]$，函数F(x)是f(x)在区间[a,b]上的一个原函数，则有:$\int_{a}^{b}f(x)dx=F(b)-F(a)$</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数A</title>
    <url>/2022/03/18/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0A/</url>
    <content><![CDATA[<h1 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h1><ul>
<li>多项式的除法</li>
<li>最大公因式<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1></li>
<li>n元排列</li>
<li>自然排列</li>
<li>逆序</li>
<li>逆序数</li>
<li>奇排列</li>
<li>偶排列</li>
<li>n阶行列式</li>
<li>把行列式的某一行(列)的各元素乘以同一数后加到另一行(列)对应的元素上，行列式的值不变<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1></li>
<li>n元单位矩阵</li>
<li>矩阵没有除法</li>
<li>矩阵的运算：$(A^T)^T=A,(A+B)^T=A^T+B^T,(\lambda A)^T=\lambda A^T,(AB)^T=B^TA^T$</li>
<li>逆矩阵</li>
<li>初等变换：对调两行(列)，行(列)上的元素乘以k倍，将行(列)上的元素乘以k倍加到另一行(列)上</li>
<li>矩阵的等价:经过初等变换，$A\to B$，记为A~B</li>
<li>矩阵的秩:R(A)</li>
<li>矩阵的初等变换不改变矩阵的秩</li>
<li>行最简形矩阵</li>
<li>初等矩阵：单位矩阵E经过一次初等变换得到的矩阵为初等矩阵<h1 id="向量组的线性相关性"><a href="#向量组的线性相关性" class="headerlink" title="向量组的线性相关性"></a>向量组的线性相关性</h1></li>
<li>向量组的秩</li>
<li>向量空间</li>
<li>基</li>
<li>维数<h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1></li>
<li>线性方程组有解的充分必要条件是系数矩阵A与增广矩阵B的秩相等</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理基础</title>
    <url>/2022/03/19/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="质点运动学"><a href="#质点运动学" class="headerlink" title="质点运动学"></a>质点运动学</h1><h2 id="参考系"><a href="#参考系" class="headerlink" title="参考系"></a>参考系</h2><ul>
<li>地心参考系</li>
<li>太阳参考系<h2 id="质点的位矢、位移和速度"><a href="#质点的位矢、位移和速度" class="headerlink" title="质点的位矢、位移和速度"></a>质点的位矢、位移和速度</h2></li>
<li>质点</li>
<li>平均速度</li>
<li>瞬时速度</li>
<li>分速度<h2 id="加速度"><a href="#加速度" class="headerlink" title="加速度"></a>加速度</h2></li>
<li>瞬时加速度</li>
<li>平均加速度</li>
<li>匀加速运动</li>
<li>重力加速度</li>
<li>自由落体运动</li>
<li>角速度<h2 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h2></li>
<li>切向加速度</li>
<li>向心加速度(法向加速度)<h2 id="相对运动"><a href="#相对运动" class="headerlink" title="相对运动"></a>相对运动</h2></li>
<li>伽利略速度变换<h1 id="运动与力"><a href="#运动与力" class="headerlink" title="运动与力"></a>运动与力</h1><h2 id="牛顿运动定律"><a href="#牛顿运动定律" class="headerlink" title="牛顿运动定律"></a>牛顿运动定律</h2></li>
<li>第一定律:任何物体都保持静止的或沿一条直线作匀速运动的状态，除非作用在它上面的力迫使它改变这种状态</li>
<li>第二定律:运动的变化与所加的动力成正比，并且发生在这力所沿的直线的方向上</li>
<li>第三定律:对于每一个作用，总有一个相等的反作用与之相反；或者说，两个物体对各自对方的相互作用总是相等的，并且指向相反的方向<h2 id="常见的几种力"><a href="#常见的几种力" class="headerlink" title="常见的几种力"></a>常见的几种力</h2></li>
<li>重力</li>
<li>弹性力</li>
<li>摩擦力<h1 id="动量与角动量"><a href="#动量与角动量" class="headerlink" title="动量与角动量"></a>动量与角动量</h1><h2 id="冲量与动量定理"><a href="#冲量与动量定理" class="headerlink" title="冲量与动量定理"></a>冲量与动量定理</h2>$Fdt=dp$<h2 id="质点的角动量和角动量定理"><a href="#质点的角动量和角动量定理" class="headerlink" title="质点的角动量和角动量定理"></a>质点的角动量和角动量定理</h2></li>
<li>角动量:$L=r\times p=r\times mv$</li>
<li>力矩:$M=r\times F=\frac{dL}{dt}$<h1 id="功和能"><a href="#功和能" class="headerlink" title="功和能"></a>功和能</h1><h2 id="功"><a href="#功" class="headerlink" title="功"></a>功</h2>$W=\int fdr$<h2 id="动能定理"><a href="#动能定理" class="headerlink" title="动能定理"></a>动能定理</h2></li>
<li>动能:$E_k=\frac{1}{2}mv^2$</li>
<li>势能:$E_p=mgh$<h2 id="机械能守恒定理"><a href="#机械能守恒定理" class="headerlink" title="机械能守恒定理"></a>机械能守恒定理</h2>$W=E_{kB}-E_{kA}-(E_{pB}-E_{pA})$<h1 id="刚体的转动"><a href="#刚体的转动" class="headerlink" title="刚体的转动"></a>刚体的转动</h1><h2 id="转动惯量的计算"><a href="#转动惯量的计算" class="headerlink" title="转动惯量的计算"></a>转动惯量的计算</h2></li>
<li>转动惯量:$J=\int r^2dm$<h2 id="转动中的功和能"><a href="#转动中的功和能" class="headerlink" title="转动中的功和能"></a>转动中的功和能</h2></li>
<li>转动动能:$E_k=\frac{1}{2}Jw^2$<h1 id="静电场"><a href="#静电场" class="headerlink" title="静电场"></a>静电场</h1></li>
<li>电荷的基本性质:两种电荷,量子性，电荷守恒</li>
<li>库伦电荷:两个静止的点电荷之间的作用力$F=\frac{kq_1q_2}{r^2}e_r=\frac{q_1q_2}{4\pi \epsilon_0r^2}e_r,k=9\times 10^9 N·m^2/C^2,\epsilon_0=\frac{1}{4k\pi}=8.85\times 10^{-12}C^2/(N·m^2)$</li>
<li>电场叠加原理:$F=\sum F_i$</li>
<li>电场强度:$E=\frac{F}{q}$</li>
<li>场强叠加原理:$E=\sum E_i=\sum_i \frac{q_i}{4\pi \epsilon_0 r_i^2}e_{ri}=\int \frac{dq}{4\pi \epsilon_0r^2}e_r$</li>
<li>电通量:$\phi_e=\int_S·EdS$</li>
<li>高斯定律:$\oint E·dS=\frac{1}{\epsilon_0}\sum q_{in}$</li>
<li>电偶极子在电场中受到的力矩:$M=p\times E$<h1 id="电势"><a href="#电势" class="headerlink" title="电势"></a>电势</h1></li>
<li>静电场是保守场:$\oint_L E·dr=0$</li>
<li>电势差:$\varphi_1-\varphi_2=\int_{P_1}^{P_2}E·dr$</li>
<li>电势:$\varphi_P=\int_{P}^{P_0}E·dr$,($P_0$是零电势点)</li>
<li>电势叠加原理:$\varphi=\sum \varphi_i$</li>
<li>点电荷的电势:$\varphi=\frac{q}{4\pi \epsilon_0r}$</li>
<li>电荷在外电场中的电势能:$W=q\varphi$</li>
<li>电荷系的静电能:$W=\frac{1}{2}\sum q\varphi $<h1 id="静电场中的电介质"><a href="#静电场中的电介质" class="headerlink" title="静电场中的电介质"></a>静电场中的电介质</h1></li>
<li>电容器的电容:$C=\frac{Q}{U}$</li>
<li>并联电容:$C=\sum C_i$</li>
<li>串联电容:$\frac{1}{C}=\sum \frac{1}{C_i}$</li>
<li>电容器的能量:$W=\frac{1}{2}\frac{Q^2}{C}=\frac{1}{2}CU^2=\frac{1}{2}QU$<h1 id="恒定电流"><a href="#恒定电流" class="headerlink" title="恒定电流"></a>恒定电流</h1></li>
<li>电流密度:$J=nqv$</li>
<li>电流:$I=\int_S J·dS=-\frac{dq}{dt}$</li>
<li>欧姆定律:$U=IR$</li>
<li>电阻:$R=\rho \frac{l}{S}$</li>
<li>焦耳定律:$P=I^2R$<h1 id="磁场"><a href="#磁场" class="headerlink" title="磁场"></a>磁场</h1></li>
<li>洛伦兹公式:$F=qv\times B$</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学导论</title>
    <url>/2022/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<p> 在这门课程中，我们老师向我们讲解了计算机的发展历史，比如说目前普遍使用的计算机结构是由冯诺依曼创立的，同时，也向我们介绍了计算机在科研、工程等领域的应用，比如人工智能帮助人们更好地认识世界、改造世界。</p>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机高级语言程序设计(C++)</title>
    <url>/2022/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(C++)/</url>
    <content><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="基本数据类型和表达式"><a href="#基本数据类型和表达式" class="headerlink" title="基本数据类型和表达式"></a>基本数据类型和表达式</h2><ul>
<li>类</li>
<li>关键字</li>
<li>对象</li>
<li>表达式</li>
<li>类型转换<h2 id="语句控制结构"><a href="#语句控制结构" class="headerlink" title="语句控制结构"></a>语句控制结构</h2></li>
<li>语句</li>
<li>分支结构</li>
<li>循环结构</li>
<li>跳转结构<h2 id="复合类型、string、vector"><a href="#复合类型、string、vector" class="headerlink" title="复合类型、string、vector"></a>复合类型、string、vector</h2></li>
<li>引用</li>
<li>指针</li>
<li>数组</li>
<li>string类型</li>
<li>vector类型<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li>
<li>局部对象</li>
<li>全局对象</li>
<li>参数传递</li>
<li>返回值类型</li>
<li>函数重载</li>
<li>函数指针和lambda表达式</li>
<li>递归调用<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2></li>
<li>定义类</li>
<li>构造函数</li>
<li>析构函数</li>
<li>运算符重载</li>
<li>静态成员</li>
<li>类成员指针<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1>使用c++编程实现了一个在调试控制台上运行的学生成绩管理系统，可以在里面模拟对学生成绩的读取、保存、修改、删除和创建等操作。</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>电工与电子技术C</title>
    <url>/2022/03/19/%E7%94%B5%E5%B7%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AFC/</url>
    <content><![CDATA[<h1 id="电路及其分析方法"><a href="#电路及其分析方法" class="headerlink" title="电路及其分析方法"></a>电路及其分析方法</h1><ul>
<li>电源</li>
<li>电压</li>
<li>电流</li>
<li>电阻</li>
<li>电阻的串联</li>
<li>电阻的并联</li>
<li>电源开路</li>
<li>电源闭路</li>
<li>晶体二极管</li>
<li>用电器<h1 id="正弦交流电路"><a href="#正弦交流电路" class="headerlink" title="正弦交流电路"></a>正弦交流电路</h1></li>
<li>周期与频率</li>
<li>幅值与有效值</li>
<li>相位与初相位</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学A2</title>
    <url>/2022/03/19/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6A2/</url>
    <content><![CDATA[<h1 id="偏导数和全微分"><a href="#偏导数和全微分" class="headerlink" title="偏导数和全微分"></a>偏导数和全微分</h1><ul>
<li>偏导数</li>
<li>全微分<h1 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h1></li>
<li>一重积分</li>
<li>二重积分</li>
<li>三重积分<h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1></li>
<li>阶数</li>
<li>微分方程组</li>
<li>再讲解一下这个和自己毕业设计的关联故事</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象程序设计</title>
    <url>/2022/03/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(C++)/</url>
    <content><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><ul>
<li>创建动态对象</li>
<li>释放动态内存</li>
<li>动态数组<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2></li>
<li>定义函数模板</li>
<li>定义类模板<h2 id="排序和查找"><a href="#排序和查找" class="headerlink" title="排序和查找"></a>排序和查找</h2></li>
<li>冒泡算法</li>
<li>二分查找<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2></li>
<li>继承</li>
<li>拷贝</li>
<li>虚函数<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1>实现了一个可视化的学生成绩管理系统，能够新建、修改、删除、存储和读取学生成绩，并且可以用饼图、表格等可视化结果。</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑</title>
    <url>/2022/03/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h2><ul>
<li>二进制</li>
<li>十进制</li>
<li>十六进制<h2 id="带符号数的代码表示"><a href="#带符号数的代码表示" class="headerlink" title="带符号数的代码表示"></a>带符号数的代码表示</h2></li>
<li>原码</li>
<li>反码</li>
<li>补码</li>
</ul>
<h1 id="逻辑代数基础"><a href="#逻辑代数基础" class="headerlink" title="逻辑代数基础"></a>逻辑代数基础</h1><h2 id="逻辑代数的基本概念"><a href="#逻辑代数的基本概念" class="headerlink" title="逻辑代数的基本概念"></a>逻辑代数的基本概念</h2><ul>
<li>交换律</li>
<li>结合律</li>
<li>分配律</li>
<li>0-1律</li>
<li>与</li>
<li>或</li>
<li>非<h2 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h2></li>
<li>与非逻辑:$\overline{A·B}$</li>
<li>或非逻辑:$\overline{A+B}$</li>
<li>与或非逻辑:$\overline{A·B+B·C}$</li>
<li>异或逻辑:$\overline{A}·B+A·\overline{B}$</li>
<li>同或逻辑:$\overline{A}·\overline{B}+A·B$<h1 id="集成逻辑门"><a href="#集成逻辑门" class="headerlink" title="集成逻辑门"></a>集成逻辑门</h1></li>
<li>或门</li>
<li>与门</li>
<li>非门</li>
<li>与非门</li>
<li>或非门</li>
<li>与或非门</li>
<li>异或门</li>
</ul>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑课程设计</title>
    <url>/2022/03/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>用与门和或门实现一个简易二进制计数器，当使用者每点一次按钮，该计数器都会计数并将总数用灯的形式反应出来。</p>
]]></content>
      <tags>
        <tag>aps</tag>
      </tags>
  </entry>
</search>
